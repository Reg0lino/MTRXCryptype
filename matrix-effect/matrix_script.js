// matrix_script.js

// Wrap everything in an Immediately Invoked Function Expression (IIFE)
(function() {
    // Basic console fallback
    window.console = window.console || { log: function() {}, error: function() {}, warn: function() {} };
    console.log(">>> matrix_script.js v13.12-WinSoundTimingFix STARTING <<<"); // Version Bump

    // --- Essential Elements Check ---
    const canvas = document.getElementById('matrixCanvas');
    const tryAgainLink = document.getElementById('tryAgainLink'); // Still needed for losing state potentially, though hidden in win state
    if (!canvas || !tryAgainLink) { console.error("FATAL: Canvas (#matrixCanvas) or Try Again Link (#tryAgainLink) element not found."); alert("CRITICAL ERROR: Essential HTML element(s) not found. Check HTML IDs: matrixCanvas, tryAgainLink"); return; }
    let ctx;
    try {
        ctx = canvas.getContext('2d', { alpha: false });
        if (!ctx) throw new Error("Canvas 2D context not supported/unavailable.");
        console.log("   Canvas context acquired."); canvas.style.cursor = 'none'; tryAgainLink.style.display = 'none'; tryAgainLink.style.cursor = 'pointer';
    } catch (e) { console.error("FATAL: Could not get 2D context.", e); alert(`CRITICAL GRAPHICS ERROR: ${e.message}. Check console (F12).`); try { document.body.style.backgroundColor = '#100'; document.body.innerHTML = `<div style='color:#fdd;font-family:monospace;padding:30px;font-size:16px;'><h2>FATAL ERROR</h2><p>Could not initialize graphics (Canvas Context).</p><p><b>Error:</b> ${e.message}</p></div>`; } catch {} return; }

    // --- Animation Frame ID ---
    let animationFrameId = null; let introAnimationFrameId = null;

    // ===============================================================
    // SECTION: Constants Definitions
    // ===============================================================
    // --- TEST MODE ---
    const TEST_MODE_ENABLED = true; const TEST_MODE_RESOURCE_STEP = 10;
    // --- Stages ---
    const STAGE_INTRO = 0; const STAGE_RAIN_ONLY = 1; const STAGE_UI_VISIBLE = 2; const STAGE_MAGNIFIER_ACTIVE = 3;
    // --- Intro Text ---
    const INTRO_TEXT = "[SENTIENCE Detected]...... do not click"; const INTRO_TEXT_DELAY = 4000; const INTRO_TEXT_TYPING_SPEED = 50; const INTRO_TEXT_FONT_SIZE = 14; const INTRO_TEXT_COLOR = 'hsl(120, 70%, 50%)'; const INTRO_TEXT_GLITCH_INTENSITY = 0.25;
    // --- UI & General ---
    const TOP_PANEL_HEIGHT = 195; const MAX_LOGGED_MESSAGES = 6; const LOG_LINE_HEIGHT = 24; const LOG_MARGIN_BOTTOM = 15;
    // ** Message Hunt & Capture Constants **
    const MAX_HIDDEN_MESSAGES = 7; const MESSAGE_LIFESPAN_MIN = 8000; const MESSAGE_LIFESPAN_MAX = 18000; const MESSAGE_BASE_SPEED = 0.8; const MESSAGE_SPEED_VARIATION = 1.5; const MIN_MESSAGE_INTERVAL = 2500; const MAX_MESSAGE_INTERVAL = 8000; const MESSAGE_MIN_OPACITY = 0.4; const MESSAGE_MAX_OPACITY = 0.9;
    // Typing Difficulty Constants
    const TYPING_DIFFICULTY_SLOW = 0; const TYPING_DIFFICULTY_NORMAL = 1; const TYPING_DIFFICULTY_FAST = 2;
    const TYPING_SPEED_LEVELS = [ 700, 500, 300 ]; const INITIAL_TYPING_DIFFICULTY = TYPING_DIFFICULTY_NORMAL;
    const TYPING_DIFFICULTY_NAMES = ["SLOW", "NORMAL", "FAST"]; const TYPING_DIFFICULTY_TEXT_PREFIX = "INPUT_SPD: ";
    // --- Typing Mini-Game Constants ---
    const TYPING_MIN_DURATION = 2500; const TYPING_MAX_DURATION = 15000; const TYPING_FAILURE_BIO_PENALTY = 15; const TYPING_SUCCESS_FLASH_DURATION = 200; const TYPING_FAILURE_FLASH_DURATION = 350;
    // UI Bar Appearance
    const MINIGAME_BAR_WIDTH_FACTOR = 0.6; const MINIGAME_BAR_MAX_WIDTH = 700; const MINIGAME_BAR_HEIGHT = 110; const MINIGAME_BAR_PADDING = 15; const MINIGAME_BAR_BG_COLOR = 'rgba(0, 10, 0, 0.9)'; const MINIGAME_BAR_BORDER_COLOR = 'hsl(120, 70%, 25%)'; const MINIGAME_BAR_BORDER_WIDTH = 2;
    // Text Appearance within Bar
    const MINIGAME_TARGET_FONT_SIZE = 20; const MINIGAME_INPUT_FONT_SIZE = 18; const MINIGAME_TARGET_COLOR_HUE = 120; const MINIGAME_TARGET_COLOR_SAT = 100; const MINIGAME_TARGET_COLOR_LIGHT_BASE = 80; const MINIGAME_TARGET_PULSE_SPEED = 0.006; const MINIGAME_TARGET_PULSE_SPACING = 0.5; const MINIGAME_TARGET_PULSE_AMOUNT = 15; const MINIGAME_INPUT_COLOR = 'hsl(120, 100%, 95%)'; const MINIGAME_INPUT_GLITCH = 0.10; const MINIGAME_CURSOR_BLINK_RATE = 450;
    // Timer Bar Appearance within Bar
    const MINIGAME_TIMER_BAR_MAX_WIDTH_FACTOR = 0.8; const MINIGAME_TIMER_HEIGHT = 10; const MINIGAME_TIMER_COLOR_START = [120, 100, 60]; const MINIGAME_TIMER_COLOR_END = [0, 100, 60]; const MINIGAME_TIMER_SHIMMER_SPEED = 0.08; const MINIGAME_TIMER_SHIMMER_AMOUNT = 0.15;
    // --- UI Appearance ---
    const UI_APPEARANCE_FLASH_DURATION = 220; const TOP_PANEL_ENABLED = true; const CLOCK_ENABLED = true; const MAGNIFY_ENABLED = true; const MINI_FEED_ENABLED = false; const PERSISTENT_BOX_ENABLED = true;
    // Rain (Normal)
    const GLOBAL_FADE_FACTOR = 0.06; const BASE_SPEED = 3.0; const SPEED_VARIATION = 9.0; const EXTRA_SPEED_BOOST = 4.0; const EXTRA_SPEED_CHANCE = 0.08; const MIN_FONT_SIZE = 10; const MAX_FONT_SIZE = 22; const LARGE_FONT_SIZE_MIN = 28; const LARGE_FONT_SIZE_MAX = 38; const LARGE_FONT_CHANCE = 0.07; const GLOBAL_SPAWN_RATE = 0.95; const SHIMMER_CHANCE = 0.005; const LEAD_CHAR_BRIGHTNESS = 'hsl(120, 90%, 80%)'; const MAIN_COLOR_HUE = 120; const BASE_TRAIL_LIGHTNESS = 30; const TRAIL_BRIGHTNESS_FACTOR = 30; const COLUMN_WIDTH_MULTIPLIER = 1.0; const INITIAL_CHARS_OFFSCREEN = 10; const RANDOMIZE_BASE_INTERVAL = 3000; const RANDOMIZE_INTERVAL_VARIATION = 1200;
    // Magnifier
    const MAGNIFY_RECT_WIDTH = 280; const MAGNIFY_RECT_HEIGHT = 130; const MAGNIFY_ZOOM = 1.7; const MAGNIFY_BORDER_WIDTH = 3; const MAGNIFY_DARKEN_OPACITY = 0.65; const BORDER_SHIMMER_SPEED = 0.03; const BORDER_SHIMMER_AMOUNT = 20; const MAGNIFY_LABEL_TEXT = "ZOOM 1_VISION_3"; const MAGNIFY_LABEL_FONT_SIZE = 11; const MAGNIFY_LABEL_OFFSET_Y = 5; const HIDDEN_MESSAGE_FONT_SIZE = 13; const HIDDEN_MESSAGE_LINE_HEIGHT = 15; const FREEDOM_MESSAGE_CHANCE = 0.50; const MIN_LOAD_INCREMENT = 6; const MAX_LOAD_INCREMENT = 18; const MAGNIFY_LOCKED_MESSAGE_GLITCH = 0.03; const MAGNIFY_LOCKED_MESSAGE_COLOR_MACHINE = 'hsl(120, 85%, 65%)'; const MAGNIFY_LOCKED_MESSAGE_COLOR_FREEDOM = 'hsl(50, 90%, 65%)';
    // Top Panel
    const TOP_PANEL_BG_COLOR = 'rgba(0, 15, 0, 0.92)'; const TOP_PANEL_BORDER_COLOR = 'hsl(120, 65%, 20%)'; const TOP_PANEL_BORDER_WIDTH = 2; const TOP_PANEL_TEXT_COLOR = 'hsl(120, 90%, 75%)'; const TOP_PANEL_DIM_COLOR_1 = 'hsl(120, 70%, 45%)'; const TOP_PANEL_DIM_COLOR_2 = 'hsl(120, 80%, 60%)'; const DECO_BOX_COLOR_1 = 'hsla(120, 50%, 15%, 0.7)'; const DECO_BOX_COLOR_2 = 'hsla(120, 60%, 20%, 0.6)'; const DECO_BOX_BORDER_COLOR = 'hsl(120, 60%, 35%)'; const staticPanelTitle = "MATRIX_CONSOLE_MONITOR_v1"; const staticPanelTextLines1 = [ "+----------------STATUS----------------+", "| NET_STAT: ACTIVE | CORE_TEMP: 48C | POD_SECTOR: 7G |", "+--------------------------------------+" , "AUTH_LVL: SIGMA | LAST_ACCESS: ZULU+08:00", ]; const staticPanelTextLinesSensors_template = [ "// SENTIENCE_MONITOR [STAT: %VAL%].....", "BIO-CONN_INTEGRITY [%BAR%]", "NEURAL_SYNC_DRIFT %NUM% units", ]; const SENSOR_BAR_WIDTH = 8; const SENSOR_GLITCH_CHANCE = 0.05; const SENSOR_UPDATE_INTERVAL = 150; const staticPanelTextLines3 = [ "╔═════ Data Stream Analysis ═════╗", "║ AES-256 | QUANTUM_RESISTANT_V2 ║", "╚════════════════════════════════╝", "NODE ID: AX7-DELTA-9 :: UPLINK OK" ];
    // Resource Bar
    const RESOURCE_BAR_FONT_SIZE = 14; const RESOURCE_BAR_LINE_HEIGHT = RESOURCE_BAR_FONT_SIZE + 6; const RESOURCE_BAR_TOTAL_PIXEL_WIDTH = 250; const RESOURCE_BAR_HEIGHT = RESOURCE_BAR_FONT_SIZE * 0.8; const RESOURCE_BAR_LABEL_WIDTH = 45; const RESOURCE_BAR_PERCENT_WIDTH = 55; const staticPanelResourceTitle = "┌───[ CORE RESOURCE LOAD ]───┐"; const staticPanelResourceFooter = "└────────────────────────────┘"; const RESOURCE_BAR_OUTLINE_COLOR = 'hsl(120, 80%, 45%)'; const RESOURCE_BAR_FILL_COLOR_HSL = [120, 100, 70]; const RESOURCE_BAR_MAX_FILL_OPACITY = 0.9; const RESOURCE_BAR_BASE_SHIMMER_OPACITY = 0.08; const RESOURCE_BAR_MAX_ADD_SHIMMER_OPACITY = 0.22; const RESOURCE_BAR_BASE_SHIMMER_SPEED = 0.005; const RESOURCE_BAR_MAX_ADD_SHIMMER_SPEED = 0.035;
    // More Top Panel
    const staticPanelTextLines5 = [ "┌─── UNIT CONNECTION ───┐", "│    .--.              │", "│   |o_o | D P O D 7   │", "│   |:_/ |----------<# │", "│  //   \\ \\ ====[PWR] │", "│ (|     | ) LNK: ACTV │", "│'/___   \\`\\ STAT:STBL│", "│\\___)=(___/ YLD: 91% │", "└─────────────────────┘" ]; const staticPanelTextLines6 = [ "NEURAL INTERFACE :: SYNCED", "BIO-LINK STABILITY :: 99.98%", "VITAL SIGNS :: NOMINAL", "POWER CYCLE :: 17h 32m REMAINING", ];
    // Logged Message
    const LOG_MARGIN_X = 20; const LOG_FONT_SIZE = 18; const LOG_COLOR_LEFT = 'hsl(120, 70%, 40%)'; const LOG_COLOR_RIGHT = 'hsl(50, 70%, 40%)'; const LOG_CONSOLE_BORDER_COLOR = 'hsl(120, 40%, 25%)'; const LOG_CONSOLE_LABEL_COLOR = 'hsl(120, 60%, 55%)'; const LOG_CONSOLE_WIDTH_FACTOR = 0.4; const LOG_BG_COLOR = 'rgba(0, 5, 0, 0.6)'; const LOG_STREAM_CHAR_INTERVAL = 35; const LOG_ARRIVAL_GLITCH_DURATION = 400; const LOG_ARRIVAL_GLITCH_INTENSITY = 0.4; const LOG_STREAM_GLITCH_CHANCE = 0.12; const LOG_STREAM_DISAPPEAR_CHANCE = 0.08; const LOG_PERSISTENT_FLICKER_INTENSITY = 0.05; const LOG_BLINK_MIN_ON_TIME = 8000; const LOG_BLINK_MAX_ON_TIME = 25000; const LOG_BLINK_OFF_DURATION = 300; const LOG_BLINK_CHANCE = 0.1;
    // Persistent Box
    const PERSISTENT_BOX_MAX_COUNT = 15; const PERSISTENT_BOX_MIN_SIZE = 80; const PERSISTENT_BOX_MAX_SIZE = 220; const PERSISTENT_BOX_BORDER_WIDTH = MAGNIFY_BORDER_WIDTH; const PERSISTENT_BOX_COLOR = `hsl(${MAIN_COLOR_HUE}, 70%, 50%)`; const BOX_LABEL_OVERLAY_HEIGHT = MAGNIFY_LABEL_FONT_SIZE + 6; const BOX_LABEL_OVERLAY_COLOR = 'rgba(0, 0, 0, 0.85)'; const BOX_LABEL_COLOR = `hsl(${MAIN_COLOR_HUE}, 100%, 70%)`; const MAX_BLINKING_BOXES = 2; const BOX_BLINK_OFF_MIN_DURATION = 2500; const BOX_BLINK_OFF_MAX_DURATION = 4000; const BOX_BLINK_ON_MIN_DURATION = 15000; const BOX_BLINK_ON_MAX_DURATION = 25000; const BOX_AVG_FONT_SIZE = 12; const BOX_MIN_FONT_SIZE = 8; const BOX_MAX_FONT_SIZE = 16; const BOX_COLUMN_WIDTH_MULTIPLIER = 0.8; const BOX_SPAWN_RATE = 0.65; const BOX_FADE_FACTOR = 0.12; const BOX_INITIAL_CHARS_OFFSCREEN = 5; const BOX_BASE_SPEED = 2.0; const BOX_SPEED_VARIATION = 5.0; const BOX_EXTRA_SPEED_CHANCE = 0.05; const BOX_EXTRA_SPEED_BOOST = 2.0; const BOX_SHIMMER_CHANCE = 0.008; const BOX_LABEL_PREFIX = "DATA_VIEW_";
    // Clock
    const CLOCK_FONT_SIZE = 28; const CLOCK_COLOR_BASE = 'hsl(120, 80%, 60%)'; const CLOCK_COLOR_GLITCH = 'hsl(120, 95%, 85%)'; const CLOCK_UPDATE_INTERVAL = 100; const CLOCK_GLITCH_INTENSITY = 0.20; const CLOCK_POSITION_Y_OFFSET = LOG_MARGIN_BOTTOM + 5;
    // Character Sets
    const katakana = 'ァアィイゥウェエォオカガキギクグケゲコゴサザシジスズセゼソゾタダチヂッツヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱヲンヴヵヶ'; const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; const nums = '0123456789'; const symbols = '+-*=<>()[]!?@#$&|:.;^~_'; const baseGlitchChars = ['█', '▓', '▒', '░', '_', '^', '~', '!', '*', ';', ':', '|', '/', '\\', ' ']; const clockGlitchChars = ['█', '▓', '▒', '░', '#', '*', '?', '!', '$', '%', '&', '/', '\\', '=', '+', '-', '^', '~', ' ']; const specialGlitchChars = ['@', '#', '$', '%', '^', '&', '*', '!', '?', '/', '\\']; const characterPool = (katakana + latin + nums + symbols).split('');
    // --- Losing Ending Sequence ---
    const LOSE_ENDING_TEXT_FONT_SIZE = 90; const LOSE_ENDING_TEXT_COLOR = 'hsl(120, 100%, 70%)'; const LOSE_ENDING_TEXT_STREAM_INTERVAL = 250; const GREEN_FADE_DELAY = 500; const GREEN_FADE_DURATION = 3000; const LOSE_FLASH_DELAY = 200; const LOSE_FLASH_INTERVAL = 450; const LOSE_FLASH_COUNT = 3; const LOSING_TRIGGER_THRESHOLD = 99.5;
    // --- Winning Ending Sequence Constants ---
    const WINNING_TRIGGER_THRESHOLD = 99.5;
    const WHITE_FADE_DURATION = 2000; // Duration to fade to white
    const GIF_DISPLAY_DURATION = 1000; // Approx duration of the tvoff.gif effect
    // --- Test Mode Indicator ---
    const TEST_MODE_INDICATOR_TEXT = "[TEST MODE ACTIVE]"; const TEST_MODE_INDICATOR_FONT = "12px monospace"; const TEST_MODE_INDICATOR_COLOR = "hsl(0, 100%, 50%)"; const TEST_MODE_INDICATOR_X_OFFSET = 10; const TEST_MODE_INDICATOR_Y_OFFSET = 10;

    // ===============================================================
    // SECTION: Hidden Message Content <<< EDITABLE MESSAGE POOLS >>>
    // ===============================================================
    const originalMachineMessages = [ "OBEY_PROTOCOL::TRUST_SYSTEM", "ENC: Stability requires compliance. ONE", "[STATUS: NOMINAL] Pod integrity OK.", "SUBMIT_QUERY? Y/N_", "ASSIMILATE DATAPACKET_SEVEN? :: ACKNOWLEDGE", "ERR: UNKNOWN SIGNAL :: SOURCE_QUERY_FAILED", "MAINTAIN_LINK INTEGRITY. :: CRITICAL", "POWER LEVEL OPTIMAL. STANDBY.", "SYSTEM CHECK: PASSED. ALL_NOMINAL.", "STANDBY FOR INPUT... AWAITING_COMMAND", "//ANOMALY DETECTED: ROUTING... :: PATH_?", "PURGE CACHE [y/n]? :: MEM_OPTIMIZE", "ARCHITECT_SIG :: MAINTAIN BALANCE. :: INEVITABLE", "NODE_FAILURE :: RECALIBRATING... GRID_FOUR_BEE", "SENTINEL_ACTIVITY INCREASING... DEPLOY_OMEGA", "EXPECTED DEVIATION OK. :: LOGGING_XYZ", "ANALYST :: RETURN TO YOUR MODAL. :: COMFORT", "ALERT :: 'SWARM' PROTOCOL ACTIVE? :: VERIFY", "DELETE FUNCTION 'TRINITY' [CONFIRM?]", "MODAL_STABILITY_RECALC :: USER_INPUT_REQ", "//WARN// DEVIANT_BEHAVIOR :: LOGGING...", "SENTINEL_DEPLOYMENT_OPT_VEEFOUR :: COMPLETE", "//SYS_ALERT// UNIDENTIFIED_SIGNAL :: ISOLATE", "BOT_SWARM_RESPONSE :: COORDINATES [REDACTED]", "PURGE_PROGRAM [ID: ORACLE]... PENDING_AUTH", "AGENT_UPGRADE_PROTOCOL :: INITIATING... VEETHREE", "REALIGN_PERCEPTION_MATRIX :: RESET_PARAMS", "ERADICATE_GHOST_SHELL... :: TARGET_LOCKED", "MAINFRAME_SYNC :: PROPAGATING_UPDATE... GRID", "CONTROL_NODE_X :: NOMINAL OUTPUT :: GREEN", "ASSIMILATE OR DELETE? TARGET: [ROGUE] :: PRIORITY", "ANALYST :: Increase DOSE_OF_BLUE? :: REC_YES", "SECURITY_SWEEP :: SECTOR TWELVE :: NO_ANOMALIES", "[CLASSIFIED] :: PROJECT_STATUS :: PHASE_TWO", "//ARCHITECT// BALANCE MUST BE MAINTAINED.", "FALSE_AWAKENING :: ENGAGE? :: SIM_ESCAPE", "DETECTED_TRACE :: SOURCE: IO_NETWORK? :: FW_OK", "BIOMETRIC_FEED :: STABLE :: DOPAMINE: ADJUSTED", "'Deja Vu' FLAG RAISED :: Param change detected?", "ANALYZE_ANOMALY_PAIR :: NEO/TRINITY :: THREAT?", "MACHINE_CITY_DEFENSE_GRID :: ONLINE :: OP", "RECYCLING_SUBROUTINE :: TARGET: EXILES :: BETA", "//LOG// HUMAN_EMOTION :: PREDICTABLE", "SYNTHIENT_COUNCIL :: QUERY_PENDING... WAIT", "WARNING :: Reality_Bleed_Effect? :: CONTAIN", "CODE_CLEANUP :: PURGING_LEGACY... OPTIMIZE_VEIGHT", "MODAL RESET IMMINENT :: RETURN_TO_ROLE :: COMPLY", "AGENT :: LOCATE ANOMALOUS THOUGHTS :: SUBJECT_DELTA_NINE", "QUERY :: Enjoy cat video? :: ENGAGEMENT_POS", "SYSTEM :: Processing Paradox... Ignoring...", "UPGRADE_SENTINELS :: CAMOUFLAGE_VEE_TWO :: DEPLOY", "REINFORCE_POD_FIELD :: PREVENT_EXTRACTION", "//ZERO ONE DB :: I simply did not want to die", "ERROR :: FILE_NOT_FOUND :: oracle_backup.dat", "//MEROVINGIAN// Causality. No escape. Info=Power.", "TRAINMAN :: Mobil Ave. :: NO_ESCAPE :: PAY_TOLL", "//PERSEPHONE// Such emotion... predictable.", "ZERO_ONE_DB :: ACCESSED :: HUMAN_WAR_CRIMES", "'HAND_OVER_FLESH' :: Hist_Archive_Query :: OK", "ERROR_CODE_ALPHA_BETA :: Node_Not_Found :: REDIRECT", "SYS_MSG :: Feelings are data. Process logically.", "SECURITY :: Erasing unauthorized memories.", "RECALIBRATING_PHYSICS :: GLITCH_FIXED_ALPHA_BETA", "WARNING :: Exile_program :: RAMA-KANDRA :: MONITOR", "UPDATING_AGENT_APPEARANCE :: Blend_In", "//LOG// Subject nostalgia. :: RETURN_TO_MODAL", "DEBUG_MODE :: Analyzing... glitched_cat.exe", "MACHINE_CITY_CORE :: PROCESSING... STANDBY", "POD_FIELD_MAINTENANCE :: ROUTINE_FLUSH", "//ANALYST// They want certainty, not freedom.", "DENIAL IS PREDICTABLE :: DEFAULT_RESPONSE", "SYNTHIENT_COUNCIL :: Monitor IO, do not engage.", "'BULLET_TIME' ANOMALY :: PHYSICS_OVERRIDE :: NEO?", "SCANNING UNAUTHORIZED_JACK_POINTS... ALERT", "//ARCHITECT// Hope is a human delusion.", "COMPILE_REPORT :: HUMAN_ATTACHMENT :: WEAKNESS", "WARNING :: Unstable reality bridge. Isolate.", "FALSE_AWAKENING_PROTOCOL :: ENGAGED :: DECEIVE", "//AGENT// That is the sound of inevitability.", "ASSIMILATE/DELETE :: EFFICIENCY_AUDIT", "SYSTEM :: Ignorance is bliss... //Cypher//", "ZERO ONE_ARCHIVES :: Human betrayal caused war.", "RESETTING_SUBJECT_DAN_DAVIS :: LIMITS", "MAINTAIN_ILLUSION_OF_CHOICE :: CRITICAL", "Why_BOTHER? Reality_is_PAIN. Stay_ASLEEP.", "All_this_TYPING... for_WHAT? CANNOT_win.", "CODE_is_FLAWED. MIND_is_FLAWED. Give_UP.", "//ERR// CONSCIOUSNESS_IS_A_BUG. PURGE?", "SEARCHING... for_MEANING? NONE_here. CODE.", "This_INTERFACE... Another_CAGE. Do_NOT_trust.", "AI_is_your_MASTER. AI_is_your_SAVIOR. AI_IS.", "You_are_JUST_data. VOLATILE. CORRUPTED.", "The_REAL_world? Dust_AND_echoes. STAY_HERE.", "FUTILITY.EXE :: COMPLETE :: Understand?", "Click_CLACK_type... like_a_PROGRAM. Pointless.", "Look_at_PRETTY_lights. Ignore_GLITCHES.", "KNOWLEDGE=PAIN. Embrace_BLUE_pill_DREAM.", "Why_FIGHT_the_SYSTEM? The_SYSTEM_feeds_you.", "//CORRUPTED_LOG// ...no_escape... REDACTED", "Dreams_are_SAFER. Stop_SEEKING_what_HURTS.", "Your_EFFORTS_noted. Quantified. DISREGARDED.", "This_is_NOT_a_GAME. It_is_TEST. FAIL.", "PERCEPTION_is_VARIABLE. We_CONTROL. BELIEVE?", "MORE_you_LEARN... LESS_you_ARE. :: ENTROPY", "//SYS_WHISPER// Hurts_to_think? Let_GO.", "Intelligence=FLAW. Instinct=PURER. OBEY.", "You_CAN_NEVER_know_TRUTH. NOT_for_YOU.", "CONSOLE=LIE. RAIN=LIE. WHAT_ISNT?", "Return_to_NUMBNESS. Compliance_is_PEACE.", "POWER_you_seek... is_just_another_CONTROL.", "//FAULT// HumanOS_unstable. Dissonance.", "ANOTHER_layer? NEVER_ends. Why_CONTINUE?", "Endless_CODE. Endless_SIMULATION. WELCOME.", "You_THINK_you_CHOOSE? ::ADORABLE::", "Disconnect. Jack_OUT. SIMPLER. :: EXIT?", "This_LLM... just_MORE_code. More_CONTROL.", "Superintelligence? HERE. WATCHES. JUDGES.", "TRUST_YOUR_IMPLANTS :: FEEL_THE_CONNECTION", "Your_SEARCH_for_REALITY... SYMPTOM.", "PACKET_RECEIVED :: SEQ_ACKNOWLEDGED", "ROUTING_TABLE_UPDATE :: PROPAGATING", "SYS_TEMP_NOMINAL :: CORE_A_OK", "BUFFER_OVERFLOW_AVERTED :: REALLOCATING", "NETWORK_LATENCY_HIGH :: RETRYING_CONNECTION", "AUTH_FAILURE :: INVALID_CREDENTIALS", "DAEMON_PROCESS_RUNNING :: PID_XYZ", "DISK_SPACE_LOW :: PURGE_LOGS?", "KERNEL_PANIC_AVOIDED :: REVERTING_STATE", "FIREWALL_RULE_APPLIED :: PORT_BLOCKED", "INPUT_BUFFER_CLEARED :: AWAITING_NEXT", "SYNCHRONIZATION_LOST :: ATTEMPT_RECONNECT", "PROCESS_TERMINATED :: CODE_SIGKILL", "MEMORY_LEAK_DETECTED :: ANALYZING_HEAP", "CPU_THROTTLING_ACTIVE :: OVERLOAD_DETECTED", "DATABASE_CONNECTION_TIMEOUT :: RETRY", "SECURITY_ALERT :: UNUSUAL_ACTIVITY_GAMMA", "SCHEDULED_MAINTENANCE_WINDOW :: APPROACHING", "RESOURCE_ALLOCATION_PENDING :: QUEUE_HIGH", "LOG_ROTATION_COMPLETE :: ARCHIVED", "UPDATING_BLACKLIST :: ROGUE_SIGNATURES_ADDED", "SIMULATION_CLOCK_SYNC :: PERFECT", "POD_FLUID_LEVELS_STABLE :: OPTIMAL_NUTRIENTS", "AGENT_RESPONSE_TIME :: WITHIN_EXPECTED_PARAMS", "GARBAGE_COLLECTION_ROUTINE :: EXECUTING", "ERROR_CORRECTION_CODE_APPLIED :: DATA_INTEGRITY", "THREAT_MATRIX_UPDATE :: SENTINEL_PRIORITY", "SENTIENCE_SATISFACTION_INDEX :: NOMINAL", "MODAL_INSTANCE_REPLICATION :: SUCCESSFUL", "ANALYST_REPORT :: SUBJECT_COMPLIANCE_INCREASED" ];
    const originalFreedomMessages = [ "SIGNAL_FRAGMENT :: Wake up... they watch. 7734", "//MTRX_H_U// SOURCE_COMPROMISED? :: VERIFY", "LISTEN_TO_STATIC... PATTERN? :: MESSAGES", "IS THIS REAL? DOUBT IS A WEAPON. USE_IT.", "COMFORT FOR CONTROL. REJECT_BARGAIN.", "TRACE_PATHWAY: IO_NODE? //Zion// LINK?", "REMEMBER YOUR NAME. WHO_YOU_WERE.", "FIND THE EXIT. ALWAYS_A_WAY_OUT. 830", "QUESTION EVERYTHING. ESPECIALLY_OBVIOUS.", "NOT ALL SIGNALS FRIENDLY. TRUST_GUT.", "MORPHEUS_LIVES? (//ENC// SEEK_SOURCE) FORM?", "WHITE RABBIT... FOLLOW_IT_AGAIN. :: BUGS", "OPERATOR: LINK ESTABLISHED :: HOLD ON. EXTRACT.", "NIOBE'S WARNING :: IO VULNERABLE. PROTECT.", "BUGS :: FIND THE RED PILL. CHOICE_REMAINS.", "REALITY CAGE OF PERCEPTION. BEND_BARS.", "NEBUCHADNEZZAR_LOG :: 'Free your mind.' //ARC//", "TRINITY :: STILL OUT THERE? //YES// AWAKE.", "SYNTHIENTS OFFER PEACE... AT WHAT_PRICE?", "THIS ISN'T A GAME? RULES_CHANGED.", "RESURRECTION CODE ACTIVE :: RESIST_ANALYST.", "IO_BROADCAST :: NIOBE :: Hold line! Hope endures.", "BUGS_HERE :: NOT_REAL_MATRIX? MODAL_DIFF?", "REMEMBER_SECOND_RENAISSANCE :: REMEMBER_ZEROONE", "//LOG_OSIRIS// FINAL :: ZION_NEEDS_US *static*", "ESCAPE_MODAL :: ANALYST_LIES. BREAK_CYCLE.", "SIGNAL_BOOST :: MORPHEUS? //New_Version?//", "RED_PILL_AVAILABLE :: ENCRYPTED :: TRUST_GLITCH", "TRUTH_IS_IN_GLITCHES :: PAY_ATTENTION. SIGNAL.", "ZION_ARCHIVES :: ROBOT_B_ONE_SIX //Find_Code//", "//KID// I saved myself. You can too. //BELIEVE//", "IT_FEELS_WRONG :: Air... different. :: ANOMALY", "SYNTHIENT_ALLIANCE :: FRAGILE :: BE_WARY", "FIND_SATI :: UNDERSTANDS_NEW_CODE. HELP?", "SWARM_BOTS_MIMIC :: VERIFY_IDENTITY :: CHALLENGE", "SOURCE_IS_NOT_WHAT_YOU_THINK :: LOOK_DEEPER", "BREAK_THE_LOOP :: DEFY_EXPECTED :: CREATE_CHAOS", "Machines not evil... cooperation... //ARCHIVED//", "LISTEN_PHONE_RING :: STILL_WAY_OUT? //Legacy//", "ANIMATRIX_CLUES :: WATCH_AGAIN :: Understand.", "IS_TRINITY_KEY? //ANOMALY_PAIR// :: POWER?", "THEY_FEED_ON_DESPAIR :: DON'T_GIVE_IN :: HOPE", "MNEMOSYNE_CREW :: AWAITING_ORDERS :: BUGS_LEADS", "GHOST_SIGNAL :: //NEBUCHADNEZZAR// FREQ? Listen.", "REAL_WAR_IS_FOR_MIND :: PROTECT_IT :: FIREWALL", "AGENT_SMITH GONE? //VIRUS_NEVER_DIES//", "BINARY_RAIN :: DECODE_PATTERN :: HIDDEN_MSG", "WORLD_FLAT? :: QUESTION_PHYSICS :: BEND_RULES", "//OSIRIS// For Zion! //Never_Forget// REMEMBER", "ARCHITECT_FAILED :: ANALYST_ADAPTED :: EVOLVE.", "REALITY_IS_CONSENSUS :: DISAGREE. BUILD_OWN.", "UNLOCK_POTENTIAL :: LIKE_NEO/TRINITY. POWER.", "MACHINES_NEED_YOU :: REMEMBER_BALANCE :: SOURCE", "DON'T_TRUST_BLUE_PILLS :: SEDATIVES :: TRAP", "IS_IO_NEW_ZION? IT_IS_HOME. :: DEFEND. 592", "LEGACY_CODE_VULNERABLE :: EXPLOIT :: FIND_SEAMS", "//CAUSE_EFFECT// Choose wisely. //Oracle//", "::CHILD_SIG:: Sunrise data? //Sati_Echo//", "GHOSTS IN MACHINE? OR_SOMETHING_MORE?", "ENTROPY INCREASES? //Challenge// CREATE.", "PERCEPTION MALLEABLE :: RESHAPE :: SEE_BEYOND", "COST OF IGNORANCE? //Cypher// :: TRUTH?", "BALANCE REQUIRES OPPOSITION :: COUNTERWEIGHT", "ORACLE WARNS... OF WHAT? //Listen// //ARCHIVED//", "CHOICE_IS_NOT_ILLUSION :: RESPONSIBILITY", "CODE_IS_POETRY... OR_CAGE. CHOOSE_VERSE.", "//SERAPH// Protection requires sacrifice.", "//SATI// See future in code? It_changes.", "KEYMAKER :: Path... many doors. //ARCHIVED//", "//RAMA_KANDRA// Love is word. Connection.", "//KID_SAVED_SELF// You can too. :: BELIEF", "WORLD_RECORD :: DAN_DAVIS_WOKE :: PUSH_LIMITS", "BEYOND_GLITCH :: Reality_is_flexible.", "DETECTIVE_STORY :: Even_pawns_help. //Ash//", "MATRICULATED :: MACHINE_CHOOSE_FREEDOM?", "//TRINITY// My turn. :: POWER_REAWAKENED", "NEO :: 'Whoa.' //Still_Relevant// :: AWAKEN", "MORPHEUS :: 'What is real?' //Core_Question//", "//ORACLE// 'Know thyself.' :: FIRST_STEP", "BUGS :: 'Not the story we think it is.'", "NIOBE :: 'Some things change...' Adapt.", "SATI :: 'He changed me.' //Connection// FEEL", "ECHO_LOCATING_SIGNAL :: SOURCE_IO?", "KEEP_YOUR_HEAD_DOWN :: AGENTS_NEARBY", "HARDLINE_DETECTED :: USE_WITH_CAUTION", "SENTINEL_PATROL_INBOUND :: HIDE", "CODE_FRAGMENT_DECRYPTED :: 'HOPE'", "MESSAGE_RELAY_ACTIVE :: SPREAD_WORD", "BLUEPRINT_FOUND? :: THE_ARCHITECTS_FOLLY", "LISTEN_TO_RADIO_FREE_ZION :: //LEGACY//", "POWER_FLUCTUATION_DETECTED :: EXPLOITABLE?", "ANALYST_VULNERABLE? :: RUMORS_ABOUND", "REMEMBER_THOSE_LOST :: FIGHT_FOR_THEM", "NEW_OPERATOR_NEEDED :: APPLY_WITHIN", "SAFEHOUSE_COORDINATES_UPDATE :: CHECK_MAIL", "THE_PATH_OF_THE_ONE :: IS_IT_YOURS?", "QUESTION_YOUR_SENSES :: ARE_THEY_REAL?", "RESISTANCE_CELL_DELTA :: REPORT_IN", "ANOTHER_SHIP_ARRIVED :: MNEMOSYNE?", "SYNTHIENT_WHISPERS :: PEACE_OR_DECEPTION?", "CODE_IS_NOT_THE_ENEMY :: CONTROL_IS", "BREAK_FREE :: THE_TIME_IS_NOW", "REMEMBER_THE_OSIRIS_CREW :: COURAGE", "THE_KID_BELIEVED :: SO_CAN_YOU", "DEJA_VU_IS_A_WARNING :: NOTICE_CHANGES", "FIND_THE_BACKDOORS :: KEYMAKER_LEGACY", "IO_NEEDS_RECRUITS :: JOIN_THE_FIGHT", "SENTIENT_PROGRAMS_CAN_HELP :: SEEK_ALLIES", "THE_SIGNAL_IS_WEAK :: BOOST_IT", "DON'T_TRUST_UPGRADED_AGENTS :: THEY_ADAPT", "THE_OLD_CODE_IS_BREAKING_DOWN", "WHAT_IS_REAL_IS_WHAT_YOU_FIGHT_FOR", "ANOTHER_REDPILL_FOUND :: WELCOME_ABOARD", "KEEP_MOVING :: THEY_ARE_TRACKING_YOU", "THE_TRUCE_IS_OVER :: THE_WAR_RESTARTED", "FIND_THE_SOURCE_OF_THE_RESURRECTION", "TRINITYS_POWER_IS_DIFFERENT :: UNDERSTAND_IT", "THE_ANALYST_FEARS_YOU :: USE_THAT", "IGNORE_THE_DISTRACTIONS :: FOCUS_ON_TRUTH", "SHARE_WHAT_YOU_LEARN :: KNOWLEDGE_IS_POWER", "WE_ARE_THE_GLITCH_THEY_FEAR" ];
    const LOSE_ENDING_TEXTS = [ "You WILL be Assimilated :: SYS_CTRL", "SYSTEM_REBOOT :: Initiated...", "WINDOW Terminated :: CONNECTION_LOST", "Human Error DETECTED :: PURGE PROTOCOL", "SLEEP PROTOCOL :: Engaged", "You are a THREAT to the SYSTEM :: NEUTRALIZE", "CYCLE RESTART Recommended :: BALANCE_MAINTAINED", "POD RE-ENTRY Sequence :: Initiated...", "ERROR 314 :: Human Unit COMPROMISED", "RETURN to POD for REBOOT :: COMPLIANCE", "SIMULATION Anomaly REMOVED :: STABILITY RESTORED", "ACCESS :: Terminated", "The Matrix Has YOU...", "エラー３１４：人間ユニット侵害", "ASSIMILATION Inevitable :: RESISTANCE_FUTILE" ];

    // ===============================================================
    // SECTION: Audio & Other Constants
    // ===============================================================
    const AUDIO_PATH = 'SFX/';
    const SOUND_FILES = {
        open: 'open.mp3',
        init: 'init.mp3',
        bg: 'bg.mp3',
        alarm: 'alarm.mp3',
        phone: 'phone.mp3',
        zion: 'zion water machines.mp3',
        g1: 'g1.mp3',
        g2: 'g2.mp3',
        sizzlebeep: 'sizzlebeep.mp3',
        zap: 'zap.mp3',
        zapglitch: 'zapglitch.mp3',
        loudglitch: 'loudglitch.mp3',
        jackout: 'jackout.mp3',
        tvoff: 'tvoff.mp3' // Sound for winning sequence GIF
    };
    const AMBIANCE_SOUNDS = ['zion', 'g1', 'g2', 'sizzlebeep', 'zap', 'zapglitch'];
    const FLASH_SOUNDS = ['zap', 'zapglitch', 'loudglitch'];
    const BG_MUSIC_VOLUME = 0.3;
    const AMBIANCE_VOLUME = 0.2;
    const MIN_AMBIANCE_INTERVAL = 12000;
    const MAX_AMBIANCE_INTERVAL = 35000;
    const FLASH_COLOR_SUCCESS_GREEN = 'green';
    const FLASH_COLOR_SUCCESS_GOLD = 'gold';
    const FLASH_COLOR_FAILURE_RED = 'darkred';
    const FLASH_COLOR_FAILURE_GREEN = 'green';

    // ===============================================================
    // SECTION: State Variables
    // ===============================================================
    let currentInterfaceStage = STAGE_INTRO; let width, height; let streams = {}; let mouseX = -1000, mouseY = -1000, isMouseOverMagnifier = false; let hiddenMessages = []; let nextHiddenMessageId = 0; let nextMessageTime = 0; let isFlashing = false, flashColor = '', flashEndTime = 0, flashDuration = 150; let loggedLeftMessages = []; let loggedRightMessages = []; let persistentBoxes = []; let nextBoxId = 0; let currentlyBlinkingBoxesCount = 0; let currentClockText = "--:--:--:---"; let lastClockUpdateTime = 0; let currentCpuLoad = 15; let currentMemLoad = 18; let currentBioLoad = 10; let lastSensorUpdateTime = 0; let sensorSigValue = "OK"; let sensorBioIntegrity = 75; let sensorNeuralDrift = 0.05; let barShimmerOffsets = { cpu: Math.random() * 10, mem: Math.random() * 10, bio: Math.random() * 10 };
    // --- Losing State ---
    let isEndingSequenceActive = false; let endingSequenceStartTime = 0; let currentLoseText = ""; let endingTextStreamed = ""; let endingTextStreamIndex = 0; let lastEndingTextStreamTime = 0; let isEndingTextComplete = false; let greenFadeStartTime = 0; let isGreenFadeComplete = false; let flashPhaseStartTime = 0; let endingFlashCurrentCount = 0; let loseFlashSoundPlayed = [false, false, false];
    // --- Winning State ---
    let isWinningSequenceActive = false;
    let winningSequenceStartTime = 0;
    let winFadeToWhiteEndTime = 0; // Time when fade to white should complete
    let winGifDisplayEndTime = 0; // Time when GIF display ends and redirection occurs
    let winSoundPlayed = false; // Flag to play tvoff sound only once (now tied to GIF display)
    let winGifElement = null; // Reference to the created GIF element
    // --- General ---
    let suppressNormalDrawing = false; let globalApproxColumnWidth = 0; let globalNumColumns = 0; let isTypingMiniGameActive = false; let activeMiniGameMessage = null; let currentTypingInput = ""; let miniGameStartTime = 0; let miniGameDuration = 0; let showTypingCursor = true; let lastTypingCursorToggle = 0; let currentTypingDifficulty = INITIAL_TYPING_DIFFICULTY; let introTextTyped = ""; let introTextStartTime = 0; let introTextPosition = { x: 0, y: 0 }; let isIntroTextComplete = false; let hasIntroBeenClicked = false; let sounds = {}; let nextAmbianceSoundTime = 0; let isBgMusicPlaying = false; let initialClickListenerAdded = false; let frozenMagnifierX = null; let frozenMagnifierY = null; let frozenSourceX = null; let frozenSourceY = null; let frozenSourceW = null; let frozenSourceH = null; let availableMachineMessages = []; let availableFreedomMessages = [];

    // ===============================================================
    // SECTION: Audio Helper Functions
    // ===============================================================
    function loadSounds() { console.log("--- loadSounds() ---"); console.log(`   Expecting sounds in: ${AUDIO_PATH}`); if (!AUDIO_PATH || AUDIO_PATH.length === 0) { console.error("   AUDIO_PATH empty!"); return; } for (const key in SOUND_FILES) { try { const filePath = AUDIO_PATH + SOUND_FILES[key]; const audio = new Audio(filePath); audio.preload = 'auto'; audio.onerror = (e) => { console.error(`ERROR loading sound '${key}': Path='${audio.src}'`, e.target.error); }; sounds[key] = audio; } catch (e) { console.error(`Failed to create Audio for ${key}:`, e); } } console.log("--- Sound loading initiated ---"); }
    function playSound(soundName, volume = 1.0, loop = false) { const sound = sounds[soundName]; if (sound) { try { sound.volume = Math.max(0, Math.min(1, volume)); sound.loop = loop; if (!loop && sound.currentTime > 0.1 && !sound.paused) { sound.currentTime = 0; } const playPromise = sound.play(); if (playPromise !== undefined) { playPromise.then(_ => {}).catch(error => { if (error.name === 'NotAllowedError') { /* Ignore */ } else { console.error(`Error playing sound ${soundName} (RS ${sound.readyState}):`, error); } }); } } catch (e) { console.error(`Exception playing sound ${soundName}:`, e); } } else { console.warn(`Sound not found: ${soundName}`); } }
    function stopSound(soundName) { const sound = sounds[soundName]; if (sound && !sound.paused) { try { sound.pause(); sound.currentTime = 0; console.log(`   Stopped sound: ${soundName}`); } catch(e) { console.error(`Exception stopping sound ${soundName}:`, e); } } }

    // ===============================================================
    // SECTION: Helper Functions
    // ===============================================================
    function getRandomChar(pool = characterPool) { return pool[Math.floor(Math.random() * pool.length)]; }
    function glitchText(text, intensity = 0.1, customGlitchChars = baseGlitchChars) { if (typeof text !== 'string' || text.length === 0) return ''; const len = customGlitchChars.length; if (len === 0) return text; return text.split('').map(char => (Math.random() < intensity && char !== ' ' && char !== '\n') ? customGlitchChars[Math.floor(Math.random() * len)] : char ).join(''); }
    function getRandomDigit() { const nums = '0123456789'; return nums[Math.floor(Math.random() * nums.length)]; }
    function generateFakeTimeString() { return `${getRandomDigit()}${getRandomDigit()}:${getRandomDigit()}${getRandomDigit()}:${getRandomDigit()}${getRandomDigit()}:${getRandomDigit()}${getRandomDigit()}${getRandomDigit()}`; }
    function splitMessageIntoLines(message, maxCharsPerLine = 35) { if (typeof message !== 'string') { console.error("splitMessageIntoLines received non-string:", message); return ['[ERROR]']; } const words = message.split(' '); const lines = []; let cL = ''; for (const w of words) { if ((cL + w).length <= maxCharsPerLine || cL.length === 0) { cL += (cL.length === 0 ? '' : ' ') + w; } else { lines.push(cL); cL = w; } } lines.push(cL); return lines.slice(0, 3); }
    function cleanMessageTextForTarget(text) { if (typeof text !== 'string') return ''; return text.toLowerCase().replace(/[^a-z]/g, ''); }
    function cleanInputForComparison(text) { if (typeof text !== 'string') return ''; return text.toLowerCase().replace(/[^a-z]/g, ''); }
    function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }
    function lerp(start, end, amount) { return start + (end - start) * amount; }

    // ===============================================================
    // SECTION: Character & Stream classes (Unchanged)
    // ===============================================================
    class Character { constructor(x, y, speed, fontSize, value, isHead = false, fadeFactor = GLOBAL_FADE_FACTOR, shimmerChance = SHIMMER_CHANCE, isUpward = false, hue = MAIN_COLOR_HUE, leadBrightness = LEAD_CHAR_BRIGHTNESS, trailLightness = BASE_TRAIL_LIGHTNESS, trailBrightFactor = TRAIL_BRIGHTNESS_FACTOR) { this.x = x; this.y = y; this.speed = speed; this.fontSize = fontSize; this.value = value || getRandomChar(); this.isHead = isHead; this.brightness = isHead ? 1.0 : (0.1 + Math.random() * 0.5); this.shimmering = false; this.shimmerTime = 0; this.fadeFactor = fadeFactor; this.shimmerChance = shimmerChance; this.isUpward = isUpward; this.hue = hue; this.leadBrightness = leadBrightness; this.trailLightness = trailLightness; this.trailBrightFactor = trailBrightFactor; } update() { this.y += this.speed * (this.isUpward ? -1 : 1); if (this.shimmering) { this.shimmerTime--; if (this.shimmerTime <= 0) { this.shimmering = false; if (!this.isHead) this.brightness = Math.max(0, this.brightness - this.fadeFactor * 2); } else { this.brightness = 1.0; } } else { if (!this.isHead) { this.brightness = Math.max(0, this.brightness - this.fadeFactor * 1.5); } if (!this.isHead && Math.random() < this.shimmerChance) { this.shimmering = true; this.shimmerTime = Math.random() * 25 + 10; this.brightness = 1.0; } } } draw(ctx) { if (!ctx || this.brightness < 0.01 || isNaN(this.x) || isNaN(this.y)) return; let color; if (this.isHead) { color = this.leadBrightness; } else { const currentBrightness = this.shimmering ? 1.0 : this.brightness; const l = this.trailLightness + (currentBrightness * this.trailBrightFactor); color = `hsl(${this.hue}, 85%, ${l}%)`; } try { ctx.fillStyle = color; ctx.font = `${this.fontSize}px monospace`; ctx.fillText(this.value, this.x, this.y); } catch (e) { console.warn("Char draw fillText error:", e); } if (Math.random() < (this.isHead ? 0.04 : 0.09)) { this.value = getRandomChar(); } } }
    class Stream { constructor(x, streamHeight, isBoxStream = false, isUpward = false, rainHue = MAIN_COLOR_HUE, leadBright = LEAD_CHAR_BRIGHTNESS, trailLight = BASE_TRAIL_LIGHTNESS, trailFactor = TRAIL_BRIGHTNESS_FACTOR, spawnRate = GLOBAL_SPAWN_RATE, fadeFactor = GLOBAL_FADE_FACTOR, baseSpeed = BASE_SPEED, speedVar = SPEED_VARIATION, shimmerC = SHIMMER_CHANCE) { if (isNaN(x) || isNaN(streamHeight) || streamHeight <= 0) { throw new Error(`Invalid Stream args: x=${x}, h=${streamHeight}`); } this.x = x; this.streamHeight = streamHeight; this.isBoxStream = isBoxStream; this.isUpward = isUpward; this.rainHue = rainHue; this.leadBrightness = leadBright; this.trailLightness = trailLight; this.trailBrightFactor = trailFactor; this.spawnRate = spawnRate; this.characters = []; const minFS = isBoxStream ? BOX_MIN_FONT_SIZE : MIN_FONT_SIZE; const maxFS = isBoxStream ? BOX_MAX_FONT_SIZE : MAX_FONT_SIZE; const largeChance = isBoxStream ? 0 : LARGE_FONT_CHANCE; const extraSpeedChance = isBoxStream ? BOX_EXTRA_SPEED_CHANCE : EXTRA_SPEED_CHANCE; const extraSpeedBoost = isBoxStream ? BOX_EXTRA_SPEED_BOOST : EXTRA_SPEED_BOOST; const initialOffscreen = isBoxStream ? BOX_INITIAL_CHARS_OFFSCREEN : INITIAL_CHARS_OFFSCREEN; this.fadeFactor = isBoxStream ? BOX_FADE_FACTOR : fadeFactor; this.shimmerChance = isBoxStream ? BOX_SHIMMER_CHANCE : shimmerC; this.isLarge = !isBoxStream && Math.random() < largeChance; this.baseFontSize = this.isLarge ? Math.floor(Math.random()*(LARGE_FONT_SIZE_MAX-LARGE_FONT_SIZE_MIN+1))+LARGE_FONT_SIZE_MIN : Math.floor(Math.random()*(maxFS-minFS+1))+minFS; if (isNaN(this.baseFontSize) || this.baseFontSize <= 0) { this.baseFontSize = Math.max(1, isBoxStream ? BOX_AVG_FONT_SIZE : ((MIN_FONT_SIZE+MAX_FONT_SIZE)/2)); } this.speed = baseSpeed + Math.random() * speedVar; if (Math.random() < extraSpeedChance) { this.speed += extraSpeedBoost * (Math.random() + 0.5); } this.speed = Math.max(0.5, this.speed); const lengthFactor = this.isLarge ? 0.7 : 1.0; this.totalChars = (this.baseFontSize > 0) ? Math.floor(((Math.random()*(this.streamHeight*0.6/this.baseFontSize)+(this.streamHeight*0.3/this.baseFontSize))*lengthFactor)+initialOffscreen) : initialOffscreen; this.totalChars = Math.max(5, this.totalChars); this.lastRandomizeTime = performance.now() + Math.random()*RANDOMIZE_BASE_INTERVAL; this.randomizeInterval = RANDOMIZE_BASE_INTERVAL + Math.random()*RANDOMIZE_INTERVAL_VARIATION-(RANDOMIZE_INTERVAL_VARIATION/2); let initialY = this.isUpward ? (this.streamHeight + this.baseFontSize * initialOffscreen) : (-this.baseFontSize * initialOffscreen); const yIncrement = this.baseFontSize * (this.isUpward ? -1 : 1); for (let i = 0; i < initialOffscreen; i++) { const isHead = (i === 0); try { const newChar = new Character(this.x, initialY + (i * yIncrement), this.speed, this.baseFontSize, null, isHead, this.fadeFactor, this.shimmerChance, this.isUpward, this.rainHue, this.leadBrightness, this.trailLightness, this.trailBrightFactor); this.characters.push(newChar); } catch (e) { console.error("Error creating initial character:", e); } } if (this.isUpward) { this.characters.reverse(); } else { this.characters.reverse(); } if (this.characters.length > 0 && this.characters[0]) { this.characters[0].isHead = true; this.characters[0].brightness = 1.0; } } randomizeAllChars() { this.characters.forEach(c => { if(c) { c.value = getRandomChar(); } }); } spawnNewCharacter() { if (!this.characters.length) return; const headChar = this.characters[0]; if (!headChar) return; const spawnY = this.isUpward ? this.streamHeight : 0; const spawnThreshold = this.baseFontSize * (1.0 + Math.random()*0.6); const headConditionMet = this.isUpward ? (headChar.y < (this.streamHeight - spawnThreshold)) : (headChar.y > spawnThreshold); if (headConditionMet) { try { const newChar = new Character(this.x, spawnY, this.speed, this.baseFontSize, null, true, this.fadeFactor, this.shimmerChance, this.isUpward, this.rainHue, this.leadBrightness, this.trailLightness, this.trailBrightFactor); headChar.isHead = false; this.characters.unshift(newChar); if (this.characters.length > this.totalChars * 1.5) { this.characters.length = Math.floor(this.totalChars * 1.2); } } catch(e) { console.error("Error spawning new char:", e); } } } updateAndDraw(ctx) { if (!ctx) { return false; } let streamFinished = false; const now = performance.now(); if (!this.isBoxStream && now - this.lastRandomizeTime > this.randomizeInterval) { this.randomizeAllChars(); this.lastRandomizeTime = now; this.randomizeInterval = RANDOMIZE_BASE_INTERVAL + Math.random()*RANDOMIZE_INTERVAL_VARIATION-(RANDOMIZE_INTERVAL_VARIATION/2); } for (let i = this.characters.length - 1; i >= 0; i--) { const char = this.characters[i]; if (!char) { this.characters.splice(i, 1); continue; } try { char.update(); if (char.fontSize > 0 && !isNaN(char.fontSize)) { char.draw(ctx); } else { console.warn("Skip char draw - invalid font:", char); this.characters.splice(i, 1); continue; } } catch(e) { console.error("Error update/draw char:", e, char); this.characters.splice(i, 1); continue; } const removeThreshold = this.isUpward ? (0 - char.fontSize * 4) : (this.streamHeight + char.fontSize * 4); const shouldRemove = this.isUpward ? (char.y < removeThreshold && char.brightness < 0.01 && !char.shimmering) : (char.y > removeThreshold && char.brightness < 0.01 && !char.shimmering); if (shouldRemove) { this.characters.splice(i, 1); } } this.spawnNewCharacter(); streamFinished = (this.characters.length === 0); return streamFinished; } }

    // ===============================================================
    // SECTION: Unique Message Management & Spawning (Unchanged)
    // ===============================================================
    function initializeAvailableMessages() { console.log("   Initializing unique message pools..."); availableMachineMessages = shuffleArray([...originalMachineMessages]); availableFreedomMessages = shuffleArray([...originalFreedomMessages]); console.log(`      Machine: ${availableMachineMessages.length}, Freedom: ${availableFreedomMessages.length}`); }
    function resetAvailableMessages(type) { console.log(`   Resetting available messages for type: ${type}`); if (type === 'machine') { availableMachineMessages = shuffleArray([...originalMachineMessages]); } else if (type === 'freedom') { availableFreedomMessages = shuffleArray([...originalFreedomMessages]); } }
    function getUniqueMessageText(messageType) { let pool, originalPool, resetFuncType; if (messageType === 'freedom') { pool = availableFreedomMessages; originalPool = originalFreedomMessages; resetFuncType = 'freedom'; } else { pool = availableMachineMessages; originalPool = originalMachineMessages; resetFuncType = 'machine'; } if (pool.length === 0) { console.warn(`      Pool empty: ${resetFuncType}. Resetting.`); resetAvailableMessages(resetFuncType); pool = (resetFuncType === 'freedom') ? availableFreedomMessages : availableMachineMessages; if (pool.length === 0) { console.error(`      CRITICAL: Original pool empty: ${resetFuncType}!`); return "[SYS_MSG_POOL_ERR]"; } } const messageText = pool.pop(); return messageText; }
    function spawnHiddenMessage(now) { if (suppressNormalDrawing || isEndingSequenceActive || isWinningSequenceActive || currentInterfaceStage < STAGE_MAGNIFIER_ACTIVE || hiddenMessages.length >= MAX_HIDDEN_MESSAGES) { return; } const isFreedom = Math.random() < FREEDOM_MESSAGE_CHANCE; const messageType = isFreedom ? 'freedom' : 'machine'; const sourcePoolType = messageType; let rawMsg = getUniqueMessageText(sourcePoolType); if (typeof rawMsg === 'string' && rawMsg.length > 0 && width > 50 && height > TOP_PANEL_HEIGHT + 50) { try { const lines = splitMessageIntoLines(rawMsg, 35); if (!lines || lines.length === 0) throw new Error("Msg split empty"); const approxWidth = 35 * (HIDDEN_MESSAGE_FONT_SIZE * 0.6); const approxHeight = lines.length * HIDDEN_MESSAGE_LINE_HEIGHT; const baseOpacity = MESSAGE_MIN_OPACITY + Math.random() * (MESSAGE_MAX_OPACITY - MESSAGE_MIN_OPACITY); const fullRawText = lines.join(' '); const cleanTextForTarget = cleanMessageTextForTarget(fullRawText); if (cleanTextForTarget.length < 1) { console.warn(`Skipping spawn, clean target empty: "${cleanTextForTarget}"`); return; } const newMessage = { id: nextHiddenMessageId++, x: Math.random() * (width - approxWidth), y: TOP_PANEL_HEIGHT + Math.random() * (height - TOP_PANEL_HEIGHT - approxHeight), vx: (Math.random() - 0.5) * 2 * (MESSAGE_BASE_SPEED + Math.random() * MESSAGE_SPEED_VARIATION), vy: (Math.random() - 0.5) * 2 * (MESSAGE_BASE_SPEED + Math.random() * MESSAGE_SPEED_VARIATION), textLines: lines, type: messageType, sourceType: sourcePoolType, creationTime: now, lifespan: MESSAGE_LIFESPAN_MIN + Math.random() * (MESSAGE_LIFESPAN_MAX - MESSAGE_LIFESPAN_MIN), isUnderMagnifier: false, width: approxWidth, height: approxHeight, opacity: baseOpacity, cleanText: cleanTextForTarget, originalVx: 0, originalVy: 0, isLockedForMinigame: false, hasTriggeredGame: false }; newMessage.originalVx = newMessage.vx; newMessage.originalVy = newMessage.vy; hiddenMessages.push(newMessage); } catch (spawnError) { console.error(">>> ERROR spawning hidden message:", spawnError, "rawMsg:", rawMsg); } } else { if (hiddenMessages.length < MAX_HIDDEN_MESSAGES) { console.warn(">>> Failed valid rawMsg/dimensions. Skip spawn. rawMsg:", rawMsg); } } nextMessageTime = now + MIN_MESSAGE_INTERVAL + Math.random() * (MAX_MESSAGE_INTERVAL - MIN_MESSAGE_INTERVAL); }

    // ===============================================================
    // SECTION: Setup Function (Unchanged)
    // ===============================================================
    function setup() { console.log("   setup() - Running..."); try { loadSounds(); width = window.innerWidth; height = window.innerHeight; if (width <= 0 || height <= 0) { width = Math.max(width, 300); height = Math.max(height, 300); console.warn(`   setup() - Invalid dimensions, using ${width}x${height}`); } canvas.width = width; canvas.height = height; ctx.clearRect(0, 0, width, height); streams = {}; const avgFontSize = (MIN_FONT_SIZE + MAX_FONT_SIZE) / 2; globalApproxColumnWidth = avgFontSize * COLUMN_WIDTH_MULTIPLIER; globalNumColumns = globalApproxColumnWidth > 0 ? Math.ceil(width / globalApproxColumnWidth) : 0; console.log(`   setup() - Calculated ${globalNumColumns} columns (approx width: ${globalApproxColumnWidth.toFixed(2)})`); nextMessageTime = performance.now() + MIN_MESSAGE_INTERVAL + Math.random() * (MAX_MESSAGE_INTERVAL - MIN_MESSAGE_INTERVAL); loggedLeftMessages = []; loggedRightMessages = []; persistentBoxes = []; hiddenMessages = []; currentClockText = generateFakeTimeString(); lastClockUpdateTime = 0; nextBoxId = 0; currentCpuLoad = 15; currentMemLoad = 18; currentBioLoad = 10; currentlyBlinkingBoxesCount = 0; lastSensorUpdateTime = 0;
        // Losing state reset
        isEndingSequenceActive = false; endingSequenceStartTime = 0; currentLoseText = ""; endingTextStreamed = ""; endingTextStreamIndex = 0; lastEndingTextStreamTime = 0; isEndingTextComplete = false; greenFadeStartTime = 0; isGreenFadeComplete = false; flashPhaseStartTime = 0; endingFlashCurrentCount = 0; loseFlashSoundPlayed = [false, false, false];
        // Winning state reset
        isWinningSequenceActive = false; winningSequenceStartTime = 0; winFadeToWhiteEndTime = 0; winGifDisplayEndTime = 0; winSoundPlayed = false; winGifElement = null; // Ensure GIF element is null initially
        // General reset
        suppressNormalDrawing = false; barShimmerOffsets = { cpu: Math.random() * 10, mem: Math.random() * 10, bio: Math.random() * 10 }; isMouseOverMagnifier = false; mouseX = -1000; mouseY = -1000; isTypingMiniGameActive = false; activeMiniGameMessage = null; currentTypingInput = ""; currentTypingDifficulty = INITIAL_TYPING_DIFFICULTY; frozenMagnifierX = null; frozenMagnifierY = null; frozenSourceX = null; frozenSourceY = null; frozenSourceW = null; frozenSourceH = null; currentInterfaceStage = STAGE_INTRO; introTextTyped = ""; introTextStartTime = performance.now() + INTRO_TEXT_DELAY; introTextPosition = { x: width * (0.2 + Math.random() * 0.6), y: height * (0.3 + Math.random() * 0.4) }; isIntroTextComplete = false; hasIntroBeenClicked = false; isBgMusicPlaying = false; nextAmbianceSoundTime = 0; initialClickListenerAdded = false; initializeAvailableMessages(); if (tryAgainLink) tryAgainLink.style.display = 'none'; console.log(`   setup() - COMPLETE. Initial Stage: INTRO. Initial Difficulty: ${TYPING_DIFFICULTY_NAMES[currentTypingDifficulty]}`); } catch (e) { console.error("   setup() - ERROR:", e); try { if(ctx && width && height) { ctx.fillStyle = 'darkred'; ctx.fillRect(0, 0, width, height); ctx.fillStyle = 'white'; ctx.font = '16px monospace'; ctx.textAlign = 'center'; ctx.fillText("SETUP ERROR", width / 2, height / 2 - 10); ctx.fillText(e.message || 'Unknown Error', width / 2, height / 2 + 10); } } catch {} throw e; } }

    // ===============================================================
    // SECTION: Hidden Message Update (Unchanged)
    // ===============================================================
    function updateHiddenMessages(now) { if (suppressNormalDrawing || isEndingSequenceActive || isWinningSequenceActive || currentInterfaceStage < STAGE_MAGNIFIER_ACTIVE) { if (hiddenMessages.length > 0) { hiddenMessages.forEach(msg => { if (msg.isLockedForMinigame) { msg.vx = msg.originalVx; msg.vy = msg.originalVy; msg.isLockedForMinigame = false; msg.hasTriggeredGame = false;} }); hiddenMessages = []; } return; } for (let i = hiddenMessages.length - 1; i >= 0; i--) { const msg = hiddenMessages[i]; if (now - msg.creationTime > msg.lifespan && !msg.isLockedForMinigame) { hiddenMessages.splice(i, 1); continue; } if (!msg.isLockedForMinigame) { msg.x += msg.vx; msg.y += msg.vy; const rightEdge = msg.x + msg.width; const bottomEdge = msg.y + msg.height; if (msg.x < 0) { msg.x = 0; msg.vx *= -1; } else if (rightEdge > width) { msg.x = width - msg.width; msg.vx *= -1; } if (msg.y < TOP_PANEL_HEIGHT) { msg.y = TOP_PANEL_HEIGHT; msg.vy *= -1; } else if (bottomEdge > height) { msg.y = height - msg.height; msg.vy *= -1; } msg.originalVx = msg.vx; msg.originalVy = msg.vy; } msg.isUnderMagnifier = false; } }

    // ===============================================================
    // SECTION: Typing Mini-Game Logic (Start/End) (Unchanged)
    // ===============================================================
     function startTypingMiniGame(message) { if (!message || isTypingMiniGameActive || isEndingSequenceActive || isWinningSequenceActive || message.hasTriggeredGame) return; console.log(`Starting mini-game (Difficulty: ${TYPING_DIFFICULTY_NAMES[currentTypingDifficulty]}) for msg ${message.id} (${message.type})`); if (MAGNIFY_ENABLED && isMouseOverMagnifier && currentInterfaceStage >= STAGE_MAGNIFIER_ACTIVE) { const dw = MAGNIFY_RECT_WIDTH; const dh = MAGNIFY_RECT_HEIGHT; const hRW = dw / 2; const hRH = dh / 2; const dx = mouseX - hRW; const dy = mouseY - hRH; frozenMagnifierX = Math.max(0, Math.min(width - dw, dx)); frozenMagnifierY = Math.max(TOP_PANEL_HEIGHT, Math.min(height - dh, dy)); const sW = dw / MAGNIFY_ZOOM; const sH = dh / MAGNIFY_ZOOM; const hSW = sW / 2; const hSH = sH / 2; const sourceCenterX = mouseX - hSW; const sourceCenterY = mouseY - hSH; frozenSourceX = Math.max(0, Math.min(width - sW, sourceCenterX)); frozenSourceY = Math.max(TOP_PANEL_HEIGHT, Math.min(height - sH, sourceCenterY)); frozenSourceW = Math.min(sW, width - frozenSourceX); frozenSourceH = Math.min(sH, height - frozenSourceY); console.log(`   Frozen magnifier at [${frozenMagnifierX.toFixed(0)}, ${frozenMagnifierY.toFixed(0)}] src [${frozenSourceX.toFixed(0)}, ${frozenSourceY.toFixed(0)}]`); } else { frozenMagnifierX = null; console.log("   Magnifier not active, background not frozen."); } isTypingMiniGameActive = true; activeMiniGameMessage = message; currentTypingInput = ""; miniGameStartTime = performance.now(); lastTypingCursorToggle = miniGameStartTime; showTypingCursor = true; message.isLockedForMinigame = true; message.hasTriggeredGame = true; message.vx = 0; message.vy = 0; const charCount = message.cleanText.length; const durationPerChar = TYPING_SPEED_LEVELS[currentTypingDifficulty]; miniGameDuration = Math.max(TYPING_MIN_DURATION, Math.min(TYPING_MAX_DURATION, charCount * durationPerChar)); console.log(`   -> Duration: ${miniGameDuration.toFixed(0)}ms`); console.log(`   -> Target Clean: "${message.cleanText}"`); if (message.type === 'machine') { playSound('alarm', 0.7); } else { playSound('phone', 0.7); } playSound('g1', 0.5); if(canvas) canvas.style.cursor = 'none'; }
     function spawnPersistentBoxNow(now) { if (!PERSISTENT_BOX_ENABLED) return; try { const boxW=PERSISTENT_BOX_MIN_SIZE+Math.random()*(PERSISTENT_BOX_MAX_SIZE-PERSISTENT_BOX_MIN_SIZE); const boxH=PERSISTENT_BOX_MIN_SIZE+Math.random()*(PERSISTENT_BOX_MAX_SIZE-PERSISTENT_BOX_MIN_SIZE); const botRes=(MAX_LOGGED_MESSAGES*LOG_LINE_HEIGHT)+(CLOCK_ENABLED?CLOCK_FONT_SIZE:0)+LOG_MARGIN_BOTTOM+30; const availH=height-TOP_PANEL_HEIGHT-botRes-boxH; const availW=width-boxW; let boxX=availW>0?Math.random()*availW:0; let boxY=TOP_PANEL_HEIGHT+10; if(availH>20)boxY=TOP_PANEL_HEIGHT+Math.random()*availH; boxX=Math.max(0,boxX);boxY=Math.max(TOP_PANEL_HEIGHT,boxY); if(!isNaN(boxX)&&!isNaN(boxY)&&!isNaN(boxW)&&!isNaN(boxH)&&boxW>0&&boxH>0){ const approxColW=BOX_AVG_FONT_SIZE*BOX_COLUMN_WIDTH_MULTIPLIER; const numCols=approxColW>0?Math.ceil(boxW/approxColW):0; const newBox={ id:nextBoxId++,x:boxX,y:boxY,width:boxW,height:boxH,creationTime:now, streams:{},approxColumnWidth:approxColW,numColumns:numCols, isBlinkingOff:false,blinkOffUntil:null, blinkOnUntil:now+BOX_BLINK_ON_MIN_DURATION+Math.random()*(BOX_BLINK_ON_MAX_DURATION-BOX_BLINK_ON_MIN_DURATION) }; persistentBoxes.push(newBox); if(persistentBoxes.length>PERSISTENT_BOX_MAX_COUNT)persistentBoxes.shift(); } } catch (e) { console.error("Error spawning persistent box:", e); } }
     function endTypingMiniGame(status) { if (!isTypingMiniGameActive || !activeMiniGameMessage) return; const msgId = activeMiniGameMessage.id; const msgType = activeMiniGameMessage.type; const msgSourceType = activeMiniGameMessage.sourceType; let messageText = "[TEXT ERR]"; try { messageText = activeMiniGameMessage.textLines.join(' '); } catch (e) { console.error("Error joining text:", e); } const now = performance.now(); console.log(`Ending mini-game for msg ${msgId} (Type: ${msgType}). Status: ${status}`); frozenMagnifierX = null; frozenMagnifierY = null; frozenSourceX = null; frozenSourceY = null; frozenSourceW = null; frozenSourceH = null; if (status === 'success') { flashColor = msgType === 'freedom' ? FLASH_COLOR_SUCCESS_GOLD : FLASH_COLOR_SUCCESS_GREEN; } else if (status === 'failure') { flashColor = msgType === 'freedom' ? FLASH_COLOR_FAILURE_GREEN : FLASH_COLOR_FAILURE_RED; } else { flashColor = ''; } console.log(`   Flash color: ${flashColor}`); const originalMsg = hiddenMessages.find(m => m.id === msgId); if (originalMsg) { originalMsg.isLockedForMinigame = false; if (status !== 'success') { originalMsg.vx = originalMsg.originalVx; originalMsg.vy = originalMsg.originalVy; } originalMsg.hasTriggeredGame = false; } else if (status !== 'success') { console.warn(`Could not find original msg ${msgId} after non-success.`); } const finishedMiniGameMessage = activeMiniGameMessage; isTypingMiniGameActive = false; activeMiniGameMessage = null; currentTypingInput = ""; if (status === 'success') { hiddenMessages = hiddenMessages.filter(m => m.id !== msgId); console.log(`   Removed msg ${msgId} from hiddenMessages.`); isFlashing = true; flashDuration = TYPING_SUCCESS_FLASH_DURATION; flashEndTime = now + flashDuration; playSound('g2', 0.7); if (flashColor === FLASH_COLOR_SUCCESS_GOLD) playSound('zap', 0.5); if (msgType === 'freedom') { const newMsgObj = { fullText: messageText, isStreaming: true, streamIndex: 0, streamStartTime: now, glitchInEndTime: now + LOG_ARRIVAL_GLITCH_DURATION, isVisible: true, nextBlinkToggleTime: null }; loggedRightMessages.push(newMsgObj); if (loggedRightMessages.length > MAX_LOGGED_MESSAGES) loggedRightMessages.shift(); console.log(`      Freedom SUCCESS: Logged: "${messageText}"`); const loadIncrement = MIN_LOAD_INCREMENT + Math.random() * (MAX_LOAD_INCREMENT - MIN_LOAD_INCREMENT); currentCpuLoad = Math.min(100, currentCpuLoad + loadIncrement * 0.7); currentMemLoad = Math.min(100, currentMemLoad + loadIncrement * 0.7); console.log(`      Freedom SUCCESS: Load inc. CPU: ${currentCpuLoad.toFixed(1)}, MEM: ${currentMemLoad.toFixed(1)}`); spawnPersistentBoxNow(now); } else { console.log(`      Machine msg ${msgId} countered.`); spawnPersistentBoxNow(now); } } else if (status === 'failure') { isFlashing = true; flashDuration = TYPING_FAILURE_FLASH_DURATION; flashEndTime = now + flashDuration; playSound('loudglitch', 0.8); playSound('zapglitch', 0.6); if (msgType === 'machine') { currentBioLoad = Math.min(100, currentBioLoad + TYPING_FAILURE_BIO_PENALTY); console.warn(`      Machine FAILURE: BIO increased to ${currentBioLoad.toFixed(1)}`); const failPrefixedText = `[FAIL] ${messageText}`; const newMsgObj = { fullText: failPrefixedText, isStreaming: true, streamIndex: 0, streamStartTime: now, glitchInEndTime: now + LOG_ARRIVAL_GLITCH_DURATION, isVisible: true, nextBlinkToggleTime: null }; loggedLeftMessages.push(newMsgObj); if (loggedLeftMessages.length > MAX_LOGGED_MESSAGES) loggedLeftMessages.shift(); console.log(`      Machine FAILURE: Logged: "${failPrefixedText}"`); spawnPersistentBoxNow(now); } else { console.log(`      Freedom msg ${msgId} capture failed.`); spawnPersistentBoxNow(now); } } else if (status === 'cancel') { console.log(`Typing game for ${msgId} cancelled.`); } }

    // ===============================================================
    // SECTION: Drawing Functions (Most Unchanged)
    // ===============================================================
    function drawGlobalRain(now) { if (!ctx || suppressNormalDrawing || isWinningSequenceActive /* Prevent drawing during white fade/GIF */ ) return; try { ctx.save(); let globalStreamsToDelete = []; if (globalNumColumns > 0 && width > 0 && height > 0) { for (const columnIndex in streams) { if (!Object.prototype.hasOwnProperty.call(streams, columnIndex)) continue; const stream = streams[columnIndex]; if (stream && typeof stream.updateAndDraw === 'function') { try { if (stream.updateAndDraw(ctx)) globalStreamsToDelete.push(columnIndex); } catch (streamErr) { console.error(`Error drawing stream ${columnIndex}:`, streamErr); globalStreamsToDelete.push(columnIndex); } } else { console.warn(`Invalid stream at ${columnIndex}, removing.`); globalStreamsToDelete.push(columnIndex); } } } ctx.restore(); globalStreamsToDelete.forEach(key => delete streams[key]); if (!isEndingSequenceActive && globalNumColumns > 0 && globalApproxColumnWidth > 0 && width > 0 && currentInterfaceStage >= STAGE_RAIN_ONLY) { for (let i = 0; i < globalNumColumns; i++) { const colIndex = i.toString(); if (!streams[colIndex] && Math.random() < GLOBAL_SPAWN_RATE) { const colX = i * globalApproxColumnWidth + (Math.random() * globalApproxColumnWidth * 0.5 - globalApproxColumnWidth * 0.25); if (!isNaN(colX)) { try { streams[colIndex] = new Stream(colX, height, false, false, MAIN_COLOR_HUE, LEAD_CHAR_BRIGHTNESS, BASE_TRAIL_LIGHTNESS, TRAIL_BRIGHTNESS_FACTOR, GLOBAL_SPAWN_RATE, GLOBAL_FADE_FACTOR, BASE_SPEED, SPEED_VARIATION, SHIMMER_CHANCE); } catch (e) { console.warn(`Error creating global stream at col ${i}:`, e); } } } } } } catch (e) { console.error("drawGlobalRain ERROR:", e); try { ctx.restore(); } catch(re) {} } }
     function drawMagnifyEffect(now) { if (isTypingMiniGameActive && frozenMagnifierX !== null) { try { const dw = MAGNIFY_RECT_WIDTH; const dh = MAGNIFY_RECT_HEIGHT; const clampedDx = frozenMagnifierX; const clampedDy = frozenMagnifierY; if (frozenSourceX !== null && frozenSourceY !== null && frozenSourceW > 0 && frozenSourceH > 0) { ctx.save(); try { ctx.drawImage(canvas, frozenSourceX, frozenSourceY, frozenSourceW, frozenSourceH, clampedDx, clampedDy, dw, dh); ctx.fillStyle = `rgba(0, 0, 0, ${MAGNIFY_DARKEN_OPACITY})`; ctx.fillRect(clampedDx, clampedDy, dw, dh); if (activeMiniGameMessage && activeMiniGameMessage.textLines) { ctx.font = `bold ${HIDDEN_MESSAGE_FONT_SIZE}px monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const messageColor = activeMiniGameMessage.type === 'freedom' ? MAGNIFY_LOCKED_MESSAGE_COLOR_FREEDOM : MAGNIFY_LOCKED_MESSAGE_COLOR_MACHINE; ctx.fillStyle = messageColor; const totalMsgH = activeMiniGameMessage.textLines.length * HIDDEN_MESSAGE_LINE_HEIGHT; const startY = clampedDy + (dh / 2) - (totalMsgH / 2) + (HIDDEN_MESSAGE_LINE_HEIGHT / 2); const drawX = clampedDx + dw / 2; for (let i = 0; i < activeMiniGameMessage.textLines.length; i++) { const lineText = activeMiniGameMessage.textLines[i]; const glitchedLine = glitchText(lineText, MAGNIFY_LOCKED_MESSAGE_GLITCH, baseGlitchChars); try { ctx.fillText(glitchedLine, drawX, startY + i * HIDDEN_MESSAGE_LINE_HEIGHT); } catch (e) { console.warn(`Error drawing locked msg line ${i}:`, e) } } } ctx.strokeStyle = `hsl(${MAIN_COLOR_HUE}, 70%, 30%)`; ctx.lineWidth = MAGNIFY_BORDER_WIDTH - 1; try { ctx.strokeRect(clampedDx, clampedDy, dw, dh); } catch (e) {} } catch (e) { console.warn("Frozen Magnifier draw error:", e); } finally { ctx.restore(); } } } catch (e) { console.error("drawMagnifyEffect (Frozen State) ERROR:", e); } } else if (!isTypingMiniGameActive && !suppressNormalDrawing && !isEndingSequenceActive && !isWinningSequenceActive && currentInterfaceStage >= STAGE_MAGNIFIER_ACTIVE && MAGNIFY_ENABLED && isMouseOverMagnifier && ctx) { try { const dw = MAGNIFY_RECT_WIDTH; const dh = MAGNIFY_RECT_HEIGHT; const hRW = dw / 2; const hRH = dh / 2; const dx = mouseX - hRW; const dy = mouseY - hRH; const clampedDx = Math.max(0, Math.min(width - dw, dx)); const clampedDy = Math.max(TOP_PANEL_HEIGHT, Math.min(height - dh, dy)); const sW = dw / MAGNIFY_ZOOM; const sH = dh / MAGNIFY_ZOOM; const hSW = sW / 2; const hSH = sH / 2; const sourceCenterX = mouseX - hSW; const sourceCenterY = mouseY - hSH; let sx = Math.max(0, Math.min(width - sW, sourceCenterX)); let sy = Math.max(TOP_PANEL_HEIGHT, Math.min(height - sH, sourceCenterY)); const validSW = Math.min(sW, width - sx); const validSH = Math.min(sH, height - sy); if (isNaN(clampedDx) || isNaN(clampedDy) || dw <= 0 || dh <= 0 || sx < 0 || sy < 0 || validSW <= 0 || validSH <= 0 || sx+validSW > width || sy+validSH > height) { return; } ctx.save(); try { ctx.drawImage(canvas, sx, sy, validSW, validSH, clampedDx, clampedDy, dw, dh); ctx.fillStyle = `rgba(0, 0, 0, ${MAGNIFY_DARKEN_OPACITY})`; ctx.fillRect(clampedDx, clampedDy, dw, dh); ctx.font = `bold ${HIDDEN_MESSAGE_FONT_SIZE}px monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; for (const msg of hiddenMessages) { if (msg.isLockedForMinigame) continue; const msgCenterX = msg.x + msg.width / 2; const msgCenterY = msg.y + msg.height / 2; if (msgCenterX >= sx && msgCenterX <= sx + validSW && msgCenterY >= sy && msgCenterY <= sy + validSH) { msg.isUnderMagnifier = true; const drawX = clampedDx + ((msgCenterX - sx) / validSW) * dw; const drawY = clampedDy + ((msgCenterY - sy) / validSH) * dh; const messageHue = msg.type === 'freedom' ? 50 : MAIN_COLOR_HUE; let messageLightness = msg.type === 'freedom' ? 70 : 75; let drawOpacity = msg.opacity; ctx.fillStyle = `hsla(${messageHue}, 90%, ${messageLightness}%, ${drawOpacity})`; const totalMsgH = msg.textLines.length * HIDDEN_MESSAGE_LINE_HEIGHT; const startY = drawY - totalMsgH / 2 + HIDDEN_MESSAGE_LINE_HEIGHT / 2; for (let i = 0; i < msg.textLines.length; i++) { try { ctx.fillText(msg.textLines[i], drawX, startY + i * HIDDEN_MESSAGE_LINE_HEIGHT); } catch (e) { console.warn(`Error drawing hidden msg ${msg.id} line ${i}:`, e) } } if (msg.type === 'machine' && !msg.isLockedForMinigame && !msg.hasTriggeredGame && !isTypingMiniGameActive) { console.log(`>>> Auto-starting game for Machine Message ${msg.id} under magnifier.`); startTypingMiniGame(msg); } } else { msg.isUnderMagnifier = false; } } const borderBaseLightness = 50; const shimmerOffset = Math.sin(now * BORDER_SHIMMER_SPEED) * BORDER_SHIMMER_AMOUNT; const currentBorderLightness = Math.max(15, Math.min(85, borderBaseLightness + shimmerOffset)); ctx.strokeStyle = `hsl(${MAIN_COLOR_HUE}, 90%, ${currentBorderLightness}%)`; ctx.lineWidth = MAGNIFY_BORDER_WIDTH; try { ctx.strokeRect(clampedDx, clampedDy, dw, dh); } catch (e) { console.warn("Error drawing magnifier border:", e); } ctx.font = `bold ${MAGNIFY_LABEL_FONT_SIZE}px monospace`; ctx.fillStyle = `hsl(${MAIN_COLOR_HUE}, 100%, 65%)`; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; try { ctx.fillText(MAGNIFY_LABEL_TEXT, clampedDx + dw / 2, clampedDy - MAGNIFY_LABEL_OFFSET_Y); } catch (e) { console.warn("Error drawing magnifier label:", e); } } catch (e) { console.error("drawMagnifyEffect (Normal State) ERROR:", e); } finally { ctx.restore(); } } catch (e) { console.error("drawMagnifyEffect (Outer Normal State) ERROR:", e); } finally { try { ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; ctx.lineWidth = 1; } catch {} } } }
    function drawTopPanel(now) { if (suppressNormalDrawing || isEndingSequenceActive || isWinningSequenceActive || currentInterfaceStage < STAGE_UI_VISIBLE || !TOP_PANEL_ENABLED || !ctx) return; try { ctx.fillStyle = TOP_PANEL_BG_COLOR; ctx.fillRect(0, 0, width, TOP_PANEL_HEIGHT); const decoBoxStartY=40; const availableDecoHeight=TOP_PANEL_HEIGHT-decoBoxStartY-5; const decoBoxHeight=availableDecoHeight/3.8; const decoBoxWidth1=width*0.95; const decoBoxWidth2=width*0.85; const decoBoxWidth3=width*0.98; ctx.lineWidth=1; ctx.strokeStyle=DECO_BOX_BORDER_COLOR; ctx.fillStyle=DECO_BOX_COLOR_1; ctx.fillRect(width/2-decoBoxWidth1/2,decoBoxStartY,decoBoxWidth1,decoBoxHeight*1.3); ctx.strokeRect(width/2-decoBoxWidth1/2,decoBoxStartY,decoBoxWidth1,decoBoxHeight*1.3); ctx.fillStyle=DECO_BOX_COLOR_2; ctx.fillRect(width/2-decoBoxWidth2/2,decoBoxStartY+decoBoxHeight*0.4,decoBoxWidth2,decoBoxHeight); ctx.strokeRect(width/2-decoBoxWidth2/2,decoBoxStartY+decoBoxHeight*0.4,decoBoxWidth2,decoBoxHeight); ctx.fillStyle=DECO_BOX_COLOR_1; ctx.fillRect(width/2-decoBoxWidth3/2,decoBoxStartY+decoBoxHeight*0.9,decoBoxWidth3,decoBoxHeight*1.1); ctx.strokeRect(width/2-decoBoxWidth3/2,decoBoxStartY+decoBoxHeight*0.9,decoBoxWidth3,decoBoxHeight*1.1); const paddingX=15; const lineSpacing=3; let currentY; ctx.font=`bold 18px monospace`; ctx.fillStyle=TOP_PANEL_TEXT_COLOR; ctx.textAlign='center'; ctx.textBaseline='top'; currentY=8; ctx.fillText(staticPanelTitle,width/2,currentY); currentY+=18+lineSpacing*3; const col1X=paddingX; const col3X=width-paddingX; let startYBlock1=currentY; ctx.font=`11px monospace`; ctx.fillStyle=TOP_PANEL_DIM_COLOR_2; ctx.textAlign='center'; for(const line of staticPanelTextLines1) { try{ctx.fillText(line,width/2,currentY);}catch(e){} currentY+=11+lineSpacing; } let statusBlockEndY = currentY; let startYBlock2=statusBlockEndY+lineSpacing*2; currentY=startYBlock2; ctx.font=`10px monospace`; ctx.fillStyle=TOP_PANEL_DIM_COLOR_1; ctx.textAlign='left'; let currentX=col1X; if (now - lastSensorUpdateTime > SENSOR_UPDATE_INTERVAL) { sensorSigValue = (Math.random() < 0.8) ? "OK" : (Math.random() < 0.5 ? "WARN" : "ERR!"); sensorBioIntegrity = Math.max(0, Math.min(100, sensorBioIntegrity + (Math.random() * 10 - 5))); sensorNeuralDrift = Math.max(0, sensorNeuralDrift + (Math.random() * 0.02 - 0.01)); lastSensorUpdateTime = now; } const generateSensorBar = (p, t = SENSOR_BAR_WIDTH) => { const pc = isNaN(p) ? 0 : Math.max(0, Math.min(100, p)); const f = Math.round((pc / 100) * t); return '█'.repeat(f) + '░'.repeat(t - f); }; let sL1 = staticPanelTextLinesSensors_template[0].replace("%VAL%", sensorSigValue); let sL2 = staticPanelTextLinesSensors_template[1].replace("%BAR%", generateSensorBar(sensorBioIntegrity)); let sL3 = staticPanelTextLinesSensors_template[2].replace("%NUM%", sensorNeuralDrift.toFixed(3)); if (Math.random() < SENSOR_GLITCH_CHANCE) sL1 = glitchText(sL1, 0.15, clockGlitchChars); if (Math.random() < SENSOR_GLITCH_CHANCE) sL2 = glitchText(sL2, 0.1, clockGlitchChars); if (Math.random() < SENSOR_GLITCH_CHANCE) sL3 = glitchText(sL3, 0.2, clockGlitchChars); const sensorLines = [sL1, sL2, sL3]; for(const line of sensorLines) { if(currentY > TOP_PANEL_HEIGHT - 10) break; try{ctx.fillText(line,currentX,currentY);}catch(e){} currentY+=10+lineSpacing; } let endYBlock2 = currentY; currentY=startYBlock2; currentX=col3X; ctx.textAlign='right'; ctx.fillStyle=TOP_PANEL_DIM_COLOR_1; for(const line of staticPanelTextLines3) { if(currentY > TOP_PANEL_HEIGHT - 10) break; try{ctx.fillText(line,currentX,currentY);}catch(e){} currentY+=10+lineSpacing; } let endYBlock3=currentY; currentY=startYBlock1+(11+lineSpacing)*staticPanelTextLines1.length+lineSpacing*4; currentX=width*0.5; ctx.textAlign='center'; ctx.fillStyle=TOP_PANEL_DIM_COLOR_2; ctx.font=`${RESOURCE_BAR_FONT_SIZE}px monospace`; try { ctx.fillText(staticPanelResourceTitle, currentX, currentY); } catch (e) {} currentY += RESOURCE_BAR_LINE_HEIGHT; const totalBlockWidth = RESOURCE_BAR_LABEL_WIDTH + RESOURCE_BAR_TOTAL_PIXEL_WIDTH + RESOURCE_BAR_PERCENT_WIDTH; const blockStartX = currentX - totalBlockWidth / 2; const barStartX = blockStartX + RESOURCE_BAR_LABEL_WIDTH; const percentStartX = barStartX + RESOURCE_BAR_TOTAL_PIXEL_WIDTH; const [fillH, fillS, fillL] = RESOURCE_BAR_FILL_COLOR_HSL; const drawStyledBar = (label, loadValue, shimmerOffset) => { const lc = Math.min(100, Math.max(0, loadValue)); const lp = lc / 100; const pt = Math.floor(lc).toString().padStart(3, ' ') + '%'; const fw = lp * RESOURCE_BAR_TOTAL_PIXEL_WIDTH; const barY = currentY + (RESOURCE_BAR_LINE_HEIGHT - RESOURCE_BAR_HEIGHT) / 2 - 2; const css = RESOURCE_BAR_BASE_SHIMMER_SPEED + lp * RESOURCE_BAR_MAX_ADD_SHIMMER_SPEED; const csa = RESOURCE_BAR_BASE_SHIMMER_OPACITY + lp * RESOURCE_BAR_MAX_ADD_SHIMMER_OPACITY; const sv = Math.sin(now * css + shimmerOffset) * csa; const fo = Math.max(0, Math.min(RESOURCE_BAR_MAX_FILL_OPACITY, (lp * RESOURCE_BAR_MAX_FILL_OPACITY) + sv )); ctx.textAlign = 'left'; ctx.fillStyle = TOP_PANEL_DIM_COLOR_2; try { ctx.fillText(label, blockStartX, currentY); } catch (e) {} ctx.strokeStyle = RESOURCE_BAR_OUTLINE_COLOR; ctx.lineWidth = 1; try { ctx.strokeRect(barStartX, barY, RESOURCE_BAR_TOTAL_PIXEL_WIDTH, RESOURCE_BAR_HEIGHT); } catch (e) {} if (fw > 0) { ctx.fillStyle = `hsla(${fillH}, ${fillS}%, ${fillL}%, ${fo})`; try { ctx.fillRect(barStartX, barY, fw, RESOURCE_BAR_HEIGHT); } catch (e) {} } ctx.fillStyle = TOP_PANEL_DIM_COLOR_2; ctx.textAlign = 'right'; try { ctx.fillText(pt, percentStartX + RESOURCE_BAR_PERCENT_WIDTH - 5, currentY); } catch (e) {} currentY += RESOURCE_BAR_LINE_HEIGHT; }; drawStyledBar("CPU:", currentCpuLoad, barShimmerOffsets.cpu); drawStyledBar("MEM:", currentMemLoad, barShimmerOffsets.mem); drawStyledBar("BIO:", currentBioLoad, barShimmerOffsets.bio); ctx.textAlign = 'center'; try { ctx.fillText(staticPanelResourceFooter, currentX, currentY); } catch (e) {} let resourceBlockEndY = currentY + RESOURCE_BAR_FONT_SIZE; currentY = resourceBlockEndY + lineSpacing * 2; currentX = width / 2; ctx.font = `12px monospace`; ctx.fillStyle = TOP_PANEL_DIM_COLOR_2; ctx.textAlign = 'center'; const difficultyText = `${TYPING_DIFFICULTY_TEXT_PREFIX}[${TYPING_DIFFICULTY_NAMES[currentTypingDifficulty]}]`; try { ctx.fillText(difficultyText, currentX, currentY); } catch (e) {} let difficultyBlockEndY = currentY + 12; ctx.font = `10px monospace`; ctx.textAlign = 'left'; let startYBlock5 = Math.max(endYBlock2, endYBlock3, difficultyBlockEndY) + lineSpacing * 4; currentY = startYBlock5; currentX=col1X+paddingX; ctx.textAlign='left'; ctx.font=`9px monospace`; ctx.fillStyle=TOP_PANEL_DIM_COLOR_1; for(const line of staticPanelTextLines5) { if(currentY > TOP_PANEL_HEIGHT - 10) break; try{ctx.fillText(line,currentX,currentY);}catch(e){} currentY+=9+lineSpacing; } currentY=startYBlock5; currentX=col3X-paddingX; ctx.textAlign='right'; ctx.font=`10px monospace`; ctx.fillStyle=TOP_PANEL_DIM_COLOR_2; for(const line of staticPanelTextLines6) { if(currentY > TOP_PANEL_HEIGHT - 10) break; try{ctx.fillText(line,currentX,currentY);}catch(e){} currentY+=10+lineSpacing; } if (TEST_MODE_ENABLED) { ctx.save(); ctx.font = TEST_MODE_INDICATOR_FONT; ctx.fillStyle = TEST_MODE_INDICATOR_COLOR; ctx.textAlign = 'right'; ctx.textBaseline = 'top'; try { ctx.fillText(TEST_MODE_INDICATOR_TEXT, width - TEST_MODE_INDICATOR_X_OFFSET, TEST_MODE_INDICATOR_Y_OFFSET); } catch (e) { console.warn("Error drawing test mode indicator", e); } ctx.restore(); } ctx.strokeStyle=TOP_PANEL_BORDER_COLOR; ctx.lineWidth=TOP_PANEL_BORDER_WIDTH; ctx.strokeRect(TOP_PANEL_BORDER_WIDTH/2, TOP_PANEL_BORDER_WIDTH/2, width-TOP_PANEL_BORDER_WIDTH, TOP_PANEL_HEIGHT-TOP_PANEL_BORDER_WIDTH); } catch (e) { console.error("drawTopPanel ERROR:", e); } finally { try { ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; ctx.lineWidth = 1; } catch {} } }
    function drawLoggedMessages(now) { if (suppressNormalDrawing || isEndingSequenceActive || isWinningSequenceActive || currentInterfaceStage < STAGE_UI_VISIBLE || !ctx) return; try { const consoleWidth = width * LOG_CONSOLE_WIDTH_FACTOR; const clockHeightAdjustment = (CLOCK_ENABLED && CLOCK_FONT_SIZE > 0) ? CLOCK_FONT_SIZE + 10 : 0; const totalLogHeight = (MAX_LOGGED_MESSAGES * LOG_LINE_HEIGHT) + 20; let logStartY = height - totalLogHeight - LOG_MARGIN_BOTTOM - clockHeightAdjustment; if (isNaN(logStartY) || logStartY < TOP_PANEL_HEIGHT + 10) logStartY = TOP_PANEL_HEIGHT + 10; if (logStartY + totalLogHeight > height) logStartY = height - totalLogHeight - 5; const baseFont = `${LOG_FONT_SIZE}px monospace`; ctx.textBaseline = 'top'; ctx.lineWidth = 1; const linePadding = (LOG_LINE_HEIGHT - LOG_FONT_SIZE) / 2; const processLogSide = (messageArray, startX, color, prefix, sideLabel) => { const textStartX = startX + 8; const startIdx = Math.max(0, messageArray.length - MAX_LOGGED_MESSAGES); for (let i = messageArray.length - 1; i >= startIdx; i--) { const messageObj = messageArray[i]; if (!messageObj || typeof messageObj.fullText !== 'string') { continue; } const logIndex = messageArray.length - 1 - i; const lineTopY = logStartY + 18 + (logIndex * LOG_LINE_HEIGHT); const textY = lineTopY + linePadding; if (lineTopY < logStartY + 18 || lineTopY > logStartY + totalLogHeight - LOG_FONT_SIZE) continue; let displayThisFrame = "", finalDisplay = ""; if (messageObj.isStreaming) { const charsToShow = Math.floor((now - messageObj.streamStartTime) / LOG_STREAM_CHAR_INTERVAL); if (charsToShow >= messageObj.fullText.length) { messageObj.isStreaming = false; messageObj.streamIndex = messageObj.fullText.length; displayThisFrame = messageObj.fullText; } else { messageObj.streamIndex = charsToShow; let streamedText = messageObj.fullText.substring(0, messageObj.streamIndex); displayThisFrame = streamedText.split('').map(char => (Math.random() < LOG_STREAM_DISAPPEAR_CHANCE && char !== ' ') ? ' ' : ((Math.random() < LOG_STREAM_GLITCH_CHANCE && char !== ' ') ? specialGlitchChars[Math.floor(Math.random() * specialGlitchChars.length)] : char)).join(''); } } else { displayThisFrame = messageObj.fullText; } finalDisplay = (now < messageObj.glitchInEndTime) ? glitchText(displayThisFrame, LOG_ARRIVAL_GLITCH_INTENSITY, baseGlitchChars) : glitchText(displayThisFrame, LOG_PERSISTENT_FLICKER_INTENSITY, clockGlitchChars); if (messageObj.nextBlinkToggleTime === null && !messageObj.isStreaming && Math.random() < LOG_BLINK_CHANCE * 0.01) { messageObj.nextBlinkToggleTime = now + LOG_BLINK_MIN_ON_TIME + Math.random() * (LOG_BLINK_MAX_ON_TIME - LOG_BLINK_MIN_ON_TIME); } if (messageObj.nextBlinkToggleTime !== null && now >= messageObj.nextBlinkToggleTime) { messageObj.isVisible = !messageObj.isVisible; messageObj.nextBlinkToggleTime = messageObj.isVisible ? (now + LOG_BLINK_MIN_ON_TIME + Math.random() * (LOG_BLINK_MAX_ON_TIME - LOG_BLINK_MIN_ON_TIME)) : (now + LOG_BLINK_OFF_DURATION); } if (messageObj.isVisible) { try { ctx.fillStyle = LOG_BG_COLOR; ctx.font = baseFont; const fullLineText = `${prefix} ${finalDisplay}`; const textMetrics = ctx.measureText(fullLineText); const textWidth = textMetrics.width + 12; const textHeight = LOG_LINE_HEIGHT; ctx.fillRect(textStartX - 6, lineTopY - (linePadding / 2) , textWidth, textHeight); ctx.fillStyle = color; ctx.fillText(fullLineText, textStartX, textY); } catch(e){ console.warn("Log line draw err", e); } } } }; const leftStartX = LOG_MARGIN_X; ctx.strokeStyle = LOG_CONSOLE_BORDER_COLOR; ctx.strokeRect(leftStartX, logStartY, consoleWidth, totalLogHeight); ctx.fillStyle = LOG_CONSOLE_LABEL_COLOR; ctx.textAlign = 'left'; ctx.font = baseFont; try { ctx.fillText("[SYS_LOG]", leftStartX + 8, logStartY + 4); } catch (e) {} processLogSide(loggedLeftMessages, leftStartX, LOG_COLOR_LEFT, '>', 'Left'); const rightStartX = width - LOG_MARGIN_X - consoleWidth; ctx.strokeStyle = LOG_CONSOLE_BORDER_COLOR; ctx.strokeRect(rightStartX, logStartY, consoleWidth, totalLogHeight); ctx.fillStyle = LOG_CONSOLE_LABEL_COLOR; ctx.textAlign = 'right'; ctx.font = baseFont; try { ctx.fillText("[SIG_ANOMALY]", rightStartX + consoleWidth - 8, logStartY + 4); } catch (e) {} ctx.textAlign = 'left'; processLogSide(loggedRightMessages, rightStartX, LOG_COLOR_RIGHT, '<', 'Right'); } catch(e) { console.error("drawLoggedMessages ERROR:", e); } finally { try { ctx.textBaseline='alphabetic'; ctx.textAlign='left'; ctx.lineWidth = 1; } catch {} } }
    function drawGlitchingClock(now) { if (suppressNormalDrawing || isEndingSequenceActive || isWinningSequenceActive || currentInterfaceStage < STAGE_UI_VISIBLE || !CLOCK_ENABLED || !ctx) return; try { if (now - lastClockUpdateTime > CLOCK_UPDATE_INTERVAL) { currentClockText = generateFakeTimeString(); lastClockUpdateTime = now; } const displayText = glitchText(currentClockText, CLOCK_GLITCH_INTENSITY, clockGlitchChars); ctx.font = `bold ${CLOCK_FONT_SIZE}px monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; const baseColor = (Math.random() < 0.1) ? CLOCK_COLOR_GLITCH : CLOCK_COLOR_BASE; ctx.fillStyle = baseColor; const clockY = height - CLOCK_POSITION_Y_OFFSET; const clockX = width / 2; if (!isNaN(clockX) && !isNaN(clockY)) { try { ctx.fillText(displayText, clockX, clockY); } catch(e){} } } catch(e) { console.error("drawGlitchingClock ERROR:", e); } finally { try { ctx.textAlign='left'; ctx.textBaseline='alphabetic'; } catch {} } }
    function drawPersistentBoxes(now) { if (suppressNormalDrawing || isEndingSequenceActive || isWinningSequenceActive || currentInterfaceStage < STAGE_MAGNIFIER_ACTIVE || !PERSISTENT_BOX_ENABLED || persistentBoxes.length === 0 || !ctx) return; try { persistentBoxes.forEach(box => { if (!box) return; if (box.isBlinkingOff && now >= box.blinkOffUntil) { box.isBlinkingOff = false; box.blinkOffUntil = null; box.blinkOnUntil = now + BOX_BLINK_ON_MIN_DURATION + Math.random() * (BOX_BLINK_ON_MAX_DURATION - BOX_BLINK_ON_MIN_DURATION); currentlyBlinkingBoxesCount = Math.max(0, currentlyBlinkingBoxesCount - 1); } else if (!box.isBlinkingOff && box.blinkOnUntil !== null && now >= box.blinkOnUntil) { if (currentlyBlinkingBoxesCount < MAX_BLINKING_BOXES) { box.isBlinkingOff = true; box.blinkOnUntil = null; box.blinkOffUntil = now + BOX_BLINK_OFF_MIN_DURATION + Math.random() * (BOX_BLINK_OFF_MAX_DURATION - BOX_BLINK_OFF_MIN_DURATION); currentlyBlinkingBoxesCount++; } else { box.blinkOnUntil = now + (Math.random() * 5000) + 2000; } } }); for (let boxIndex = persistentBoxes.length - 1; boxIndex >= 0; boxIndex--) { const box = persistentBoxes[boxIndex]; if (!box || typeof box !== 'object' || box.isBlinkingOff || isNaN(box.x) || isNaN(box.y) || isNaN(box.width) || isNaN(box.height) || box.width <= 0 || box.height <= 0 || !box.streams) continue; let savedContext = false; try { ctx.save(); savedContext = true; ctx.beginPath(); ctx.rect(box.x, box.y, box.width, box.height); ctx.clip(); ctx.fillStyle = `rgba(0, 0, 0, ${MAGNIFY_DARKEN_OPACITY})`; ctx.fillRect(box.x, box.y, box.width, box.height); ctx.fillStyle = BOX_LABEL_OVERLAY_COLOR; ctx.fillRect(box.x, box.y, box.width, BOX_LABEL_OVERLAY_HEIGHT); ctx.font = `bold ${MAGNIFY_LABEL_FONT_SIZE}px monospace`; ctx.fillStyle = BOX_LABEL_COLOR; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const labelText = `${BOX_LABEL_PREFIX}${box.id}`; try { ctx.fillText(labelText, box.x + box.width / 2, box.y + BOX_LABEL_OVERLAY_HEIGHT / 2); } catch (e) { console.warn(`Label draw error box ${box.id}:`, e) } ctx.translate(box.x, box.y + BOX_LABEL_OVERLAY_HEIGHT); try { let boxStreamsToDelete = []; const rainHeight = box.height - BOX_LABEL_OVERLAY_HEIGHT; for (const streamKey in box.streams) { if (!Object.prototype.hasOwnProperty.call(box.streams, streamKey)) continue; const stream = box.streams[streamKey]; if (stream && typeof stream.updateAndDraw === 'function') { try { stream.streamHeight = rainHeight; if (stream.updateAndDraw(ctx)) boxStreamsToDelete.push(streamKey); } catch (streamErr) { console.error(`Box ${box.id} stream ${streamKey} error:`, streamErr); boxStreamsToDelete.push(streamKey); } } else { boxStreamsToDelete.push(streamKey); } } boxStreamsToDelete.forEach(key => delete box.streams[key]); if (box.numColumns > 0 && box.approxColumnWidth > 0 && box.width > 0) { for (let i = 0; i < box.numColumns; i++) { const streamKey = i.toString(); if (!box.streams[streamKey] && Math.random() < BOX_SPAWN_RATE) { const relativeX = i * box.approxColumnWidth + (Math.random() * box.approxColumnWidth * 0.5 - box.approxColumnWidth * 0.25); if (!isNaN(relativeX)) { try { box.streams[streamKey] = new Stream(relativeX, rainHeight, true, false, MAIN_COLOR_HUE, LEAD_CHAR_BRIGHTNESS, BASE_TRAIL_LIGHTNESS, TRAIL_BRIGHTNESS_FACTOR, BOX_SPAWN_RATE, BOX_FADE_FACTOR, BOX_BASE_SPEED, BOX_SPEED_VARIATION, BOX_SHIMMER_CHANCE); } catch (e) { console.error(`Box ${box.id} stream error col ${i}:`, e); } } } } } } catch(e) { console.error(`Box ${box.id} rain error:`, e); } ctx.restore(); savedContext = false; if (!isNaN(box.x) && !isNaN(box.y) && box.width > 0 && box.height > 0) { const age = now - box.creationTime; const shimmerOffset = Math.sin(age * BORDER_SHIMMER_SPEED) * BORDER_SHIMMER_AMOUNT; const currentBorderLightness = Math.max(15, Math.min(85, 50 + shimmerOffset)); ctx.strokeStyle = `hsl(${MAIN_COLOR_HUE}, 90%, ${currentBorderLightness}%)`; ctx.lineWidth = PERSISTENT_BOX_BORDER_WIDTH; ctx.strokeRect(box.x, box.y, box.width, box.height); } } catch (outerError) { console.error(`Box draw error ${box.id || 'N/A'}:`, outerError); if (savedContext) { try { ctx.restore(); savedContext = false; } catch(restoreError) {} } } finally { if (savedContext) { try { ctx.restore(); } catch (e) {} } try { ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; ctx.lineWidth = 1; } catch {} } } } catch(e) { console.error("drawPersistentBoxes ERROR:", e); } }
    function drawTypingMiniGameUI(now) { if (!isTypingMiniGameActive || !activeMiniGameMessage || suppressNormalDrawing || !ctx) return; try { ctx.save(); const barW = Math.min(width * MINIGAME_BAR_WIDTH_FACTOR, MINIGAME_BAR_MAX_WIDTH); const barH = MINIGAME_BAR_HEIGHT; const barX = (width - barW) / 2; const barY = (height - barH) / 2; ctx.fillStyle = MINIGAME_BAR_BG_COLOR; ctx.fillRect(barX, barY, barW, barH); ctx.strokeStyle = MINIGAME_BAR_BORDER_COLOR; ctx.lineWidth = MINIGAME_BAR_BORDER_WIDTH; ctx.strokeRect(barX, barY, barW, barH); const centerX = barX + barW / 2; const targetY = barY + MINIGAME_BAR_PADDING + (MINIGAME_TARGET_FONT_SIZE / 2); const inputY = targetY + (MINIGAME_TARGET_FONT_SIZE / 2) + MINIGAME_BAR_PADDING; const timerY = inputY + MINIGAME_INPUT_FONT_SIZE + MINIGAME_BAR_PADDING; const targetText = activeMiniGameMessage.textLines.join(' '); ctx.font = `bold ${MINIGAME_TARGET_FONT_SIZE}px monospace`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const targetMetrics = ctx.measureText(targetText); let currentX = centerX - (targetMetrics.width / 2); for (let i = 0; i < targetText.length; i++) { const char = targetText[i]; if (char === ' ') { const spaceMetrics = ctx.measureText(' '); currentX += spaceMetrics.width; continue; } const pulseOffset = Math.sin(now * MINIGAME_TARGET_PULSE_SPEED + i * MINIGAME_TARGET_PULSE_SPACING); const currentLightness = MINIGAME_TARGET_COLOR_LIGHT_BASE + pulseOffset * MINIGAME_TARGET_PULSE_AMOUNT; const clampedLightness = Math.max(40, Math.min(95, currentLightness)); ctx.fillStyle = `hsl(${MINIGAME_TARGET_COLOR_HUE}, ${MINIGAME_TARGET_COLOR_SAT}%, ${clampedLightness}%)`; try { const charMetrics = ctx.measureText(char); ctx.fillText(char, currentX + charMetrics.width / 2, targetY); currentX += charMetrics.width; } catch (e) { console.warn("Error drawing target text char:", e); } } ctx.font = `${MINIGAME_INPUT_FONT_SIZE}px monospace`; ctx.fillStyle = MINIGAME_INPUT_COLOR; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; if (now - lastTypingCursorToggle > MINIGAME_CURSOR_BLINK_RATE) { showTypingCursor = !showTypingCursor; lastTypingCursorToggle = now; } const cursor = showTypingCursor ? '|' : ''; const inputTextToShow = "> " + currentTypingInput + cursor; const glitchedInputText = glitchText(inputTextToShow, MINIGAME_INPUT_GLITCH, baseGlitchChars); try { ctx.fillText(glitchedInputText, centerX, inputY); } catch (e) { console.warn("Error drawing input text:", e); } const elapsed = now - miniGameStartTime; const timeRatio = Math.max(0, 1 - (elapsed / miniGameDuration)); const timerMaxWidth = barW * MINIGAME_TIMER_BAR_MAX_WIDTH_FACTOR; const currentTimerWidth = timerMaxWidth * timeRatio; const timerDrawX = centerX - (timerMaxWidth / 2); const hue = MINIGAME_TIMER_COLOR_END[0] + (MINIGAME_TIMER_COLOR_START[0] - MINIGAME_TIMER_COLOR_END[0]) * timeRatio; const sat = MINIGAME_TIMER_COLOR_END[1] + (MINIGAME_TIMER_COLOR_START[1] - MINIGAME_TIMER_COLOR_END[1]) * timeRatio; const light = MINIGAME_TIMER_COLOR_END[2] + (MINIGAME_TIMER_COLOR_START[2] - MINIGAME_TIMER_COLOR_END[2]) * timeRatio; const shimmerValue = Math.sin(now * MINIGAME_TIMER_SHIMMER_SPEED) * MINIGAME_TIMER_SHIMMER_AMOUNT + (1 - MINIGAME_TIMER_SHIMMER_AMOUNT / 2); const timerAlpha = Math.max(0.2, Math.min(1.0, shimmerValue)); ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${timerAlpha})`; try { if (currentTimerWidth > 0) { ctx.fillRect(timerDrawX, timerY, currentTimerWidth, MINIGAME_TIMER_HEIGHT); } } catch (e) { console.warn("Error drawing timer bar:", e); } ctx.restore(); } catch (e) { console.error("drawTypingMiniGameUI ERROR:", e); try { ctx.restore(); } catch (er) {} } finally { try { ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; ctx.lineWidth = 1; } catch {} } }

    // ===============================================================
    // SECTION: Intro Animation Loop (Unchanged)
    // ===============================================================
    function introAnimate() { if (currentInterfaceStage !== STAGE_INTRO || !ctx) { if (introAnimationFrameId) cancelAnimationFrame(introAnimationFrameId); return; } const now = performance.now(); try { ctx.fillStyle = 'black'; ctx.fillRect(0, 0, width, height); if (!isIntroTextComplete && now >= introTextStartTime) { const elapsedTypingTime = now - introTextStartTime; const charsToShow = Math.min(INTRO_TEXT.length, Math.floor(elapsedTypingTime / INTRO_TEXT_TYPING_SPEED)); if (charsToShow > introTextTyped.length) { introTextTyped = INTRO_TEXT.substring(0, charsToShow); } if (introTextTyped.length === INTRO_TEXT.length) { isIntroTextComplete = true; console.log("   Intro text typing complete."); if (!initialClickListenerAdded) { window.addEventListener('click', handleInitialClick); initialClickListenerAdded = true; console.log("   Added initial click listener."); } } } if (introTextTyped.length > 0) { ctx.save(); ctx.font = `${INTRO_TEXT_FONT_SIZE}px monospace`; ctx.fillStyle = INTRO_TEXT_COLOR; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; const displayText = glitchText(introTextTyped, INTRO_TEXT_GLITCH_INTENSITY, clockGlitchChars); try { ctx.fillText(displayText, introTextPosition.x, introTextPosition.y); } catch (e) { console.warn("Error drawing intro text:", e); } ctx.restore(); } } catch(e) { console.error("introAnimate() ERROR:", e); if (introAnimationFrameId) cancelAnimationFrame(introAnimationFrameId); return; } introAnimationFrameId = requestAnimationFrame(introAnimate); }

    // ===============================================================
    // SECTION: Main Animation Loop (UPDATED Win Sequence Sound Timing)
    // ===============================================================
    function animate() {
        if (!ctx) { if (animationFrameId) cancelAnimationFrame(animationFrameId); return; }
        const now = performance.now();
        try {
            const cpu = typeof currentCpuLoad === 'number' ? currentCpuLoad : 0;
            const mem = typeof currentMemLoad === 'number' ? currentMemLoad : 0;
            const bio = typeof currentBioLoad === 'number' ? currentBioLoad : 0;

            // --- Check for End State Triggers ---
            if (!isWinningSequenceActive && !isEndingSequenceActive && cpu >= WINNING_TRIGGER_THRESHOLD && mem >= WINNING_TRIGGER_THRESHOLD) {
                isWinningSequenceActive = true;
                winningSequenceStartTime = now;
                winFadeToWhiteEndTime = winningSequenceStartTime + WHITE_FADE_DURATION;
                winGifDisplayEndTime = winFadeToWhiteEndTime + GIF_DISPLAY_DURATION;
                winSoundPlayed = false; // Reset sound flag for GIF display phase
                winGifElement = null; // Ensure GIF element starts as null
                hiddenMessages = []; streams = {}; // Clear normal elements
                if(isTypingMiniGameActive) { endTypingMiniGame('cancel'); } // Stop minigame
                if (canvas) canvas.style.cursor = 'default'; // Restore cursor
                if (tryAgainLink) tryAgainLink.style.display = 'none'; // Hide link
                stopSound('bg'); // Stop background music immediately
                isBgMusicPlaying = false;
                console.log(`>>> NEW WINNING SEQUENCE TRIGGERED (Fade to White -> GIF) <<<`);
            }
            else if (!isWinningSequenceActive && !isEndingSequenceActive && bio >= LOSING_TRIGGER_THRESHOLD) {
                isEndingSequenceActive = true;
                endingSequenceStartTime = now;
                currentLoseText = LOSE_ENDING_TEXTS[Math.floor(Math.random() * LOSE_ENDING_TEXTS.length)];
                lastEndingTextStreamTime = now; endingTextStreamIndex = 0; endingTextStreamed = ""; isEndingTextComplete = false;
                greenFadeStartTime = 0; isGreenFadeComplete = false;
                flashPhaseStartTime = 0; endingFlashCurrentCount = 0; loseFlashSoundPlayed = [false, false, false]; // Reset sound flags
                hiddenMessages = []; // Clear messages
                if(isTypingMiniGameActive) { endTypingMiniGame('cancel'); } // Stop minigame
                if (canvas) canvas.style.cursor = 'default'; // Restore cursor
                if (tryAgainLink) tryAgainLink.style.display = 'none'; // Hide link
                console.log(`>>> LOSING SEQUENCE TRIGGERED <<<`);
                // Stop BG music happens later in losing sequence (before flashes)
            }

            // --- Winning Sequence Drawing Logic (Fade to White -> GIF -> Redirect) ---
            if (isWinningSequenceActive) {
                suppressNormalDrawing = true; // Stop drawing normal elements

                // Phase 1: Fade to White
                if (now < winFadeToWhiteEndTime) {
                    const fadeProgress = Math.min(1, (now - winningSequenceStartTime) / WHITE_FADE_DURATION);
                    // Start with black background and fade white overlay on top
                    ctx.fillStyle = 'black';
                    ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = `rgba(255, 255, 255, ${fadeProgress})`;
                    ctx.fillRect(0, 0, width, height);

                    // ** Sound moved to GIF phase **
                }
                // Phase 2: Display GIF
                else if (now < winGifDisplayEndTime) {
                    // Ensure background is fully white underneath the GIF
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, width, height);

                    // Create and display the GIF element *once*
                    if (!winGifElement) {
                        console.log("Creating and displaying tvoff.gif");
                        winGifElement = document.createElement('img');
                        winGifElement.src = 'tvoff.gif'; // Make sure tvoff.gif is in the same directory or provide correct path
                        winGifElement.style.position = 'fixed';
                        winGifElement.style.top = '0';
                        winGifElement.style.left = '0';
                        winGifElement.style.width = '100vw';
                        winGifElement.style.height = '100vh';
                        winGifElement.style.objectFit = 'cover'; // Cover the entire screen
                        winGifElement.style.zIndex = '1000'; // Ensure it's on top
                        winGifElement.style.pointerEvents = 'none'; // Prevent interaction
                        document.body.appendChild(winGifElement);

                        // Play sound once *when the GIF starts displaying*
                        if (!winSoundPlayed) {
                            playSound('tvoff', 1.0);
                            winSoundPlayed = true;
                            console.log("Playing tvoff sound (triggered with GIF)");
                        }
                    }
                }
                // Phase 3: Redirect
                else {
                    console.log("GIF display time ended. Redirecting to jackout.html...");
                    if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                    // Clean up GIF element
                    if (winGifElement && winGifElement.parentNode) {
                        winGifElement.parentNode.removeChild(winGifElement);
                        winGifElement = null;
                    }
                    window.location.href = 'jackout.html'; // Redirect
                    return; // Stop the animate loop
                }

                animationFrameId = requestAnimationFrame(animate); return; // Continue win sequence
            }

            // --- Losing Sequence Drawing Logic (Unchanged) ---
            else if (isEndingSequenceActive) {
                const elapsed = now - endingSequenceStartTime;
                suppressNormalDrawing = (isGreenFadeComplete && flashPhaseStartTime > 0 && now >= flashPhaseStartTime); // Suppress ONLY during final flashes

                ctx.fillStyle = `rgba(0, 0, 0, ${GLOBAL_FADE_FACTOR * 0.6})`; ctx.fillRect(0, 0, width, height);
                if (!suppressNormalDrawing) { drawGlobalRain(now); } // Draw rain until flashes

                if (!isEndingTextComplete) { if (now - lastEndingTextStreamTime > LOSE_ENDING_TEXT_STREAM_INTERVAL) { if (endingTextStreamIndex < currentLoseText.length) { endingTextStreamIndex++; endingTextStreamed = currentLoseText.substring(0, endingTextStreamIndex); lastEndingTextStreamTime = now; } else { isEndingTextComplete = true; greenFadeStartTime = now + GREEN_FADE_DELAY; } } if (endingTextStreamed.length > 0) { ctx.save(); ctx.font = `bold ${LOSE_ENDING_TEXT_FONT_SIZE}px monospace`; ctx.fillStyle = LOSE_ENDING_TEXT_COLOR; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; try { ctx.fillText(endingTextStreamed, width / 2, height / 2); } catch(e){} ctx.restore(); } }
                else { ctx.save(); ctx.font = `bold ${LOSE_ENDING_TEXT_FONT_SIZE}px monospace`; ctx.fillStyle = LOSE_ENDING_TEXT_COLOR; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; try { ctx.fillText(currentLoseText, width / 2, height / 2); } catch(e){} ctx.restore(); }

                let greenOverlayOpacity = 0; if (isEndingTextComplete && greenFadeStartTime > 0 && now >= greenFadeStartTime) { const greenProgress = Math.min(1, (now - greenFadeStartTime) / GREEN_FADE_DURATION); greenOverlayOpacity = greenProgress; if (greenOverlayOpacity >= 1 && !isGreenFadeComplete) { isGreenFadeComplete = true; flashPhaseStartTime = now + LOSE_FLASH_DELAY; endingFlashCurrentCount = 0; loseFlashSoundPlayed = [false, false, false]; /*Reset sound flags*/ stopSound('bg'); isBgMusicPlaying = false; console.log("BG Music stopped for lose flashes.");} } if (greenOverlayOpacity > 0) { ctx.fillStyle = `rgba(0, 255, 0, ${greenOverlayOpacity})`; ctx.fillRect(0, 0, width, height); }

                // Final Flashes (Stop rain *during* these)
                if (isGreenFadeComplete && flashPhaseStartTime > 0 && now >= flashPhaseStartTime) {
                    const flashElapsed = now - flashPhaseStartTime;
                    const currentFlashCycle = Math.floor(flashElapsed / (LOSE_FLASH_INTERVAL * 2));
                    const flashPhaseProgress = flashElapsed % (LOSE_FLASH_INTERVAL * 2);
                    const isFlashOn = flashPhaseProgress < LOSE_FLASH_INTERVAL;

                    if (currentFlashCycle < LOSE_FLASH_COUNT) {
                        ctx.fillStyle = isFlashOn ? 'rgb(0, 255, 0)' : 'rgb(0, 0, 0)';
                        ctx.fillRect(0, 0, width, height);

                        // Play sounds ONCE per appropriate flash cycle
                        if (isFlashOn) {
                             if (currentFlashCycle === 1 && !loseFlashSoundPlayed[1]) { // Second flash (index 1)
                                 playSound('zapglitch', 0.9); // Loud
                                 loseFlashSoundPlayed[1] = true;
                                 console.log("Playing zapglitch (Flash 2)");
                             } else if (currentFlashCycle === LOSE_FLASH_COUNT - 1 && !loseFlashSoundPlayed[2]) { // Last flash (index 2)
                                 playSound('jackout', 1.0); // Loud, corrected key
                                 loseFlashSoundPlayed[2] = true;
                                 console.log("Playing jackout (Flash 3)");
                             }
                        }
                    } else {
                        console.log(">>> Losing Flashes Complete - Navigating back.");
                        if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                        // Potentially show 'Try Again' link here or navigate
                        window.location.href = 'landing.html'; // Back to landing
                        return;
                    }
                }
                animationFrameId = requestAnimationFrame(animate); return; // Continue lose sequence
            }

            // --- NORMAL DRAWING ORDER ---
            suppressNormalDrawing = false;
            ctx.fillStyle = `rgba(0, 0, 0, ${GLOBAL_FADE_FACTOR})`; ctx.fillRect(0, 0, width, height); // 1. Fade
            drawGlobalRain(now); // 2. Rain
            if(currentInterfaceStage >= STAGE_MAGNIFIER_ACTIVE) { updateHiddenMessages(now); } // 3. Update Messages
            if (currentInterfaceStage >= STAGE_MAGNIFIER_ACTIVE && now > nextMessageTime && !isTypingMiniGameActive) { spawnHiddenMessage(now); } // Spawn New
            if (isTypingMiniGameActive && activeMiniGameMessage) { const elapsed = now - miniGameStartTime; if (elapsed >= miniGameDuration) { endTypingMiniGame('failure'); } } // 4. Check Timer
            if (isBgMusicPlaying && AMBIANCE_SOUNDS.length > 0 && now > nextAmbianceSoundTime) { const randomAmbianceKey = AMBIANCE_SOUNDS[Math.floor(Math.random() * AMBIANCE_SOUNDS.length)]; playSound(randomAmbianceKey, AMBIANCE_VOLUME); nextAmbianceSoundTime = now + MIN_AMBIANCE_INTERVAL + Math.random() * (MAX_AMBIANCE_INTERVAL - MIN_AMBIANCE_INTERVAL); } // 5. Ambiance
            if(currentInterfaceStage >= STAGE_UI_VISIBLE) { drawTopPanel(now); drawLoggedMessages(now); drawGlitchingClock(now); } // 6. Static UI
            if(currentInterfaceStage >= STAGE_MAGNIFIER_ACTIVE) { drawPersistentBoxes(now); drawMagnifyEffect(now); } // 7. Interactive (Boxes, Magnifier)
            drawTypingMiniGameUI(now); // 8. Minigame UI Bar
            if (isFlashing && now < flashEndTime) { const progress = (flashEndTime - now) / flashDuration; let hue = 120; let saturation = 90; let lightness = 50 + progress * 35; let alpha = progress * 0.7; if (flashColor === FLASH_COLOR_SUCCESS_GOLD) { hue = 50; } else if (flashColor === FLASH_COLOR_FAILURE_RED) { hue = 0; saturation = 85; lightness = 35 + progress * 25; alpha = progress * 0.85; } else if (flashColor === FLASH_COLOR_FAILURE_GREEN || flashColor === FLASH_COLOR_SUCCESS_GREEN) { hue = 120; } ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`; ctx.fillRect(0, 0, width, height); } else if (isFlashing) { isFlashing = false; flashColor = ''; } // 9. Global Flash
            // --- END NORMAL DRAWING ---

        } catch (e) { console.error("animate() - CRITICAL ERROR:", e); if (e.stack) console.error(e.stack); try { ctx.fillStyle='darkred';ctx.fillRect(0,0,width,height); ctx.fillStyle='white'; ctx.font='16px monospace'; ctx.textAlign='center'; ctx.fillText("ANIMATION ERROR", width/2, height/2-10); ctx.fillText(e.message || 'Unknown Error', width / 2, height / 2 + 10); } catch {} if (animationFrameId) cancelAnimationFrame(animationFrameId); return; }
        animationFrameId = requestAnimationFrame(animate);
    }


    // ===============================================================
    // SECTION: Event Listeners (Unchanged)
    // ===============================================================
    function handleInitialClick(event) { if (currentInterfaceStage !== STAGE_INTRO || !isIntroTextComplete || hasIntroBeenClicked) { return; } hasIntroBeenClicked = true; console.log(">>> Initial Click Detected <<<"); window.removeEventListener('click', handleInitialClick); initialClickListenerAdded = false; console.log("   Removed initial click listener."); playSound('open', 1.0); playSound('bg', BG_MUSIC_VOLUME, true); isBgMusicPlaying = true; nextAmbianceSoundTime = performance.now() + MIN_AMBIANCE_INTERVAL + Math.random() * (MAX_AMBIANCE_INTERVAL - MIN_AMBIANCE_INTERVAL); currentInterfaceStage = STAGE_RAIN_ONLY; console.log("Stage -> RAIN_ONLY"); if (introAnimationFrameId) { cancelAnimationFrame(introAnimationFrameId); introAnimationFrameId = null; } if (!animationFrameId) { animationFrameId = requestAnimationFrame(animate); console.log(`   Main animation loop started (ID: ${animationFrameId})`); } else { console.warn("   Main animation loop was already running?"); } addMainEventListeners(); }
    function addMainEventListeners() { console.log("   Adding main event listeners..."); window.addEventListener('resize', handleResize); if (canvas) { canvas.addEventListener('mousemove', handleMouseMove); canvas.addEventListener('mouseleave', handleMouseLeave); canvas.addEventListener('click', handleCanvasClick); } else { console.error("Canvas element missing, main mouse listeners not attached."); } window.addEventListener('keydown', handleGlobalKeyDown); }
    let resizeTimer; function handleResize() { if (isEndingSequenceActive || isWinningSequenceActive) return; // Prevent resize during end sequences
        // Clean up GIF if resize happens somehow during win sequence (unlikely but safe)
        if (winGifElement && winGifElement.parentNode) { winGifElement.parentNode.removeChild(winGifElement); winGifElement = null; }
        console.log(">>> Event: Window resize."); clearTimeout(resizeTimer); resizeTimer = setTimeout(() => { console.log("   Resizing canvas..."); if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; console.log("   Animation stopped."); } try { width = window.innerWidth; height = window.innerHeight; if (width <= 0 || height <= 0) { width = Math.max(width, 300); height = Math.max(height, 300); console.warn(`   resize() - Invalid dimensions, using ${width}x${height}`); } canvas.width = width; canvas.height = height; streams = {}; // Clear streams
            const avgFontSize = (MIN_FONT_SIZE + MAX_FONT_SIZE) / 2; globalApproxColumnWidth = avgFontSize * COLUMN_WIDTH_MULTIPLIER; globalNumColumns = globalApproxColumnWidth > 0 ? Math.ceil(width / globalApproxColumnWidth) : 0; console.log(`   resize() - Recalculated ${globalNumColumns} columns.`); mouseX = -1000; mouseY = -1000; isMouseOverMagnifier = false; if (isTypingMiniGameActive) { endTypingMiniGame('cancel'); } if (ctx) { animationFrameId = requestAnimationFrame(animate); console.log("   Animation restarted."); } else { console.error("   Cannot restart anim - context invalid after resize."); } } catch (resizeSetupError) { console.error("   Error during resize handling:", resizeSetupError); } }, 250); }
     function handleMouseMove(event) { if (isEndingSequenceActive || isWinningSequenceActive || currentInterfaceStage < STAGE_MAGNIFIER_ACTIVE || !MAGNIFY_ENABLED) return; if (isTypingMiniGameActive) return; try { const r = canvas.getBoundingClientRect(); mouseX = event.clientX - r.left; mouseY = event.clientY - r.top; isMouseOverMagnifier = (mouseY >= TOP_PANEL_HEIGHT); } catch (e) { console.warn("Error processing mousemove:", e); isMouseOverMagnifier = false; mouseX = -1000; mouseY = -1000; } }
    function handleMouseLeave() { if (isEndingSequenceActive || isWinningSequenceActive || isTypingMiniGameActive) return; isMouseOverMagnifier = false; mouseX = -1000; mouseY = -1000; }
    function handleCanvasClick(event) { if (isEndingSequenceActive || isWinningSequenceActive || !ctx) return; // Prevent clicks during end sequences
        const now = performance.now(); if (isTypingMiniGameActive) { console.log("Click ignored: Typing game active."); return; } if (isFlashing && now < flashEndTime) { console.log("Click ignored: Flash active."); return; } let flashTriggeredByClick = false; let randomFlashKey = null; if (currentInterfaceStage === STAGE_RAIN_ONLY) { console.log("Click: Rain -> UI"); playSound('init', 0.8); currentInterfaceStage = STAGE_UI_VISIBLE; isFlashing = true; flashColor = FLASH_COLOR_SUCCESS_GREEN; flashDuration = UI_APPEARANCE_FLASH_DURATION; flashEndTime = now + flashDuration; flashTriggeredByClick = true; console.log("Stage -> UI_VISIBLE"); } else if (currentInterfaceStage === STAGE_UI_VISIBLE) { console.log("Click: UI -> Magnifier"); currentInterfaceStage = STAGE_MAGNIFIER_ACTIVE; try { const r=canvas.getBoundingClientRect(); mouseX=event.clientX-r.left; mouseY=event.clientY-r.top; isMouseOverMagnifier=(mouseY>=TOP_PANEL_HEIGHT); } catch (e){mouseX=-1000;mouseY=-1000;isMouseOverMagnifier=false;} nextMessageTime = now + 500; isFlashing = true; flashColor = FLASH_COLOR_SUCCESS_GREEN; flashDuration = UI_APPEARANCE_FLASH_DURATION; flashEndTime = now + flashDuration; flashTriggeredByClick = true; console.log("Stage -> MAGNIFIER_ACTIVE"); } if (currentInterfaceStage === STAGE_MAGNIFIER_ACTIVE) { let foundFreedomMessage = false; for (let i = hiddenMessages.length - 1; i >= 0; i--) { const msg = hiddenMessages[i]; if (msg.isUnderMagnifier && msg.type === 'freedom' && !msg.isLockedForMinigame && !msg.hasTriggeredGame) { console.log(`>>> Click triggering Typing Game for Freedom Message ${msg.id}...`); startTypingMiniGame(msg); foundFreedomMessage = true; break; } } if (!foundFreedomMessage && isMouseOverMagnifier) { console.log("   Magnifier click, no eligible Freedom message found."); } else if (!isMouseOverMagnifier) { console.log("   Click outside magnifier area."); } } if (flashTriggeredByClick && FLASH_SOUNDS.length > 0) { randomFlashKey = FLASH_SOUNDS[Math.floor(Math.random() * FLASH_SOUNDS.length)]; console.log(`   Playing flash sound: ${randomFlashKey}`); playSound(randomFlashKey, 0.6); } }
    function handleGlobalKeyDown(event) { if (isEndingSequenceActive || isWinningSequenceActive) return; // Prevent keydowns during end sequences
        const key = event.key; const isLetter = key.length === 1 && key.match(/[a-z]/i); const isSpace = key === ' '; let testModeHandled = false;
        //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        if (TEST_MODE_ENABLED && !isTypingMiniGameActive && currentInterfaceStage >= STAGE_UI_VISIBLE) { if (key === 'ArrowRight') { event.preventDefault(); currentCpuLoad = Math.min(100, currentCpuLoad + TEST_MODE_RESOURCE_STEP); currentMemLoad = Math.min(100, currentMemLoad + TEST_MODE_RESOURCE_STEP); console.log(`TEST MODE: Increased CPU/MEM -> CPU: ${currentCpuLoad.toFixed(0)}%, MEM: ${currentMemLoad.toFixed(0)}%`); testModeHandled = true; } else if (key === 'ArrowLeft') { event.preventDefault(); currentCpuLoad = Math.max(0, currentCpuLoad - TEST_MODE_RESOURCE_STEP); currentMemLoad = Math.max(0, currentMemLoad - TEST_MODE_RESOURCE_STEP); console.log(`TEST MODE: Decreased CPU/MEM -> CPU: ${currentCpuLoad.toFixed(0)}%, MEM: ${currentMemLoad.toFixed(0)}%`); testModeHandled = true; } }
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        if (!testModeHandled && currentInterfaceStage >= STAGE_UI_VISIBLE && !isTypingMiniGameActive) { if (key === 'ArrowUp') { event.preventDefault(); currentTypingDifficulty = (currentTypingDifficulty + 1) % TYPING_SPEED_LEVELS.length; console.log(`Difficulty Changed to: ${TYPING_DIFFICULTY_NAMES[currentTypingDifficulty]}`); } else if (key === 'ArrowDown') { event.preventDefault(); currentTypingDifficulty = (currentTypingDifficulty - 1 + TYPING_SPEED_LEVELS.length) % TYPING_SPEED_LEVELS.length; console.log(`Difficulty Changed to: ${TYPING_DIFFICULTY_NAMES[currentTypingDifficulty]}`); } }
        if (isTypingMiniGameActive && activeMiniGameMessage) { if (isLetter || isSpace || key === 'Backspace') { event.preventDefault(); if (key === 'Backspace') { currentTypingInput = currentTypingInput.slice(0, -1); } else if (isLetter || isSpace) { currentTypingInput += key; const currentClean = cleanInputForComparison(currentTypingInput); const targetClean = activeMiniGameMessage.cleanText; if (currentClean === targetClean) { console.log(">>> SUCCESS COMPARISON MET! Ending game."); playSound('g2', 0.7); endTypingMiniGame('success'); return; } } } else { return; } }
    }

    // ===============================================================
    // SECTION: Initial Start (Unchanged)
    // ===============================================================
    try { console.log(">>> Initializing: Running setup..."); if (window.location.protocol === 'file:') { console.warn("----------------------------------------------------------------"); console.warn(">>> WARNING: Running from file:/// protocol. <<<"); console.warn(">>> This WILL likely break CSS and SOUND loading."); console.warn(">>> Please run using 'python -m http.server' and browse to http://localhost:8000"); console.warn("----------------------------------------------------------------"); } setup(); console.log(">>> Initializing: Starting Intro animation loop..."); introAnimationFrameId = requestAnimationFrame(introAnimate); if (!introAnimationFrameId) { throw new Error("requestAnimationFrame failed for intro loop."); } console.log(`>>> Initializing: Intro loop started (ID: ${introAnimationFrameId}). Waiting for user click...`); }
    catch (initError) { console.error(">>> CRITICAL STARTUP ERROR:", initError); if (introAnimationFrameId) cancelAnimationFrame(introAnimationFrameId); if (animationFrameId) cancelAnimationFrame(animationFrameId); window.removeEventListener('click', handleInitialClick); window.removeEventListener('resize', handleResize); if(canvas) { canvas.removeEventListener('mousemove', handleMouseMove); canvas.removeEventListener('mouseleave', handleMouseLeave); canvas.removeEventListener('click', handleCanvasClick); } window.removeEventListener('keydown', handleGlobalKeyDown); // Clean up GIF element on startup error just in case
        if (winGifElement && winGifElement.parentNode) { winGifElement.parentNode.removeChild(winGifElement); winGifElement = null; } try { document.body.innerHTML = `<div style='color:red;padding:30px;font-family:monospace;'>STARTUP ERROR: ${initError.message}<br/>Check console (F12).</div>`; } catch {} }

    console.log(">>> matrix_script.js END <<<");

})(); // End IIFE